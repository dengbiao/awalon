# 技术方案：游戏数据管理

## 1. 总体架构

阿瓦隆微信小游戏的游戏数据管理系统采用微服务架构，通过独立的游戏数据服务管理游戏房间、游戏进程和历史数据，并提供高效的数据访问和实时同步机制。

```plantuml
@startuml
!theme plain
skinparam componentStyle uml2

package "客户端层" {
  [微信小游戏客户端] as Client
}

cloud "API网关" {
  [WebSocket网关] as WSGateway
  [HTTP API网关] as HTTPGateway
}

package "游戏数据服务" {
  [房间管理服务] as RoomService
  [游戏状态服务] as GameStateService
  [游戏历史服务] as GameHistoryService
  [回放服务] as ReplayService
  [数据备份服务] as BackupService
}

package "实时通信层" {
  [状态同步管理器] as SyncManager
  [事件总线] as EventBus
  [断线重连处理器] as ReconnectHandler
}

package "数据存储层" {
  database "MongoDB" {
    [房间集合] as RoomCollection
    [游戏事件集合] as EventCollection
    [游戏状态集合] as StateCollection
    [游戏历史集合] as HistoryCollection
  }

  database "Redis" {
    [活跃房间缓存] as RoomCache
    [游戏状态缓存] as StateCache
    [锁管理器] as LockManager
    [发布/订阅通道] as PubSub
  }
}

Client --> WSGateway : 实时通信
Client --> HTTPGateway : REST请求

WSGateway --> SyncManager : 实时状态更新
SyncManager --> EventBus : 发布事件
WSGateway --> ReconnectHandler : 断线重连

HTTPGateway --> RoomService : 房间操作
HTTPGateway --> GameHistoryService : 历史查询
HTTPGateway --> ReplayService : 回放请求

RoomService --> RoomCollection : 持久化
RoomService --> RoomCache : 高速访问
RoomService --> EventBus : 发布房间事件

GameStateService --> StateCollection : 定期快照
GameStateService --> StateCache : 实时状态
GameStateService --> EventBus : 监听/发布事件

GameHistoryService --> HistoryCollection : 查询历史
GameHistoryService --> EventCollection : 查询事件

ReplayService --> EventCollection : 获取事件流
ReplayService --> StateCollection : 获取状态快照

BackupService --> RoomCollection : 备份
BackupService --> EventCollection : 备份
BackupService --> StateCollection : 备份

EventBus --> PubSub : 跨服务事件传递
SyncManager --> StateCache : 读写状态
ReconnectHandler --> StateCache : 获取当前状态

@enduml
```

### 1.1 核心组件说明

1. **房间管理服务（RoomService）**

   - 负责游戏房间的创建、配置、加入、退出等生命周期管理
   - 维护房间元数据和玩家列表
   - 提供房间状态查询和过滤功能

2. **游戏状态服务（GameStateService）**

   - 管理实时游戏状态
   - 处理游戏事件和状态转换
   - 生成游戏状态快照
   - 处理游戏逻辑验证

3. **游戏历史服务（GameHistoryService）**

   - 管理已完成游戏的历史记录
   - 提供游戏统计和分析功能
   - 支持历史查询和筛选

4. **回放服务（ReplayService）**

   - 基于事件流重建游戏过程
   - 提供游戏回放数据访问
   - 支持关键时刻标记和跳转

5. **状态同步管理器（SyncManager）**

   - 实现客户端与服务器的状态同步
   - 处理增量更新和全量更新
   - 确保多客户端状态一致性

6. **事件总线（EventBus）**
   - 采用事件溯源模式管理游戏事件
   - 提供事件订阅和发布机制
   - 支持事件重放和状态重建

### 1.2 数据流架构

游戏数据系统采用事件驱动的架构，主要数据流如下：

1. **游戏事件流**

   - 客户端操作 → WebSocket 网关 → 游戏状态服务 → 事件总线 → 事件存储
   - 事件总线 → 状态同步管理器 → WebSocket 网关 → 客户端状态更新

2. **状态持久化流**

   - 游戏状态服务 → 定期状态快照 → 状态存储
   - 游戏状态服务 → 实时状态更新 → Redis 缓存

3. **历史数据流**

   - 游戏结束 → 游戏历史归档 → 历史存储
   - 客户端请求 → HTTP API 网关 → 游戏历史服务 → 查询历史 → 返回结果

4. **回放数据流**
   - 请求回放 → 回放服务 → 加载初始状态 → 按序应用事件 → 生成回放数据流

### 1.3 技术选型

| 组件       | 技术选择         | 说明                                               |
| ---------- | ---------------- | -------------------------------------------------- |
| 持久化存储 | MongoDB          | 灵活的文档模型适合游戏数据，支持复杂查询和聚合分析 |
| 缓存层     | Redis            | 高性能内存数据库，支持发布/订阅和原子操作          |
| 通信层     | Socket.IO        | 基于 WebSocket 的实时通信库，支持断线重连          |
| 服务实现   | Node.js + NestJS | 高性能异步框架，适合 IO 密集型应用                 |
| 数据序列化 | JSON/MessagePack | 高效的数据序列化方案，适合实时数据传输             |
| 事件存储   | 事件溯源模式     | 保存完整状态变更历史，便于回放和审计               |

## 2. 数据模型设计

本节详细描述阿瓦隆游戏数据的各个核心模型设计，包括游戏房间、游戏进程状态、事件和历史记录等。

### 2.1 游戏房间数据模型

游戏房间是玩家进行游戏的容器，包含房间配置、玩家信息和当前游戏状态。

```typescript
interface GameRoom {
  _id: ObjectId; // MongoDB文档ID
  roomId: string; // 房间唯一标识
  roomCode: string; // 房间邀请码（6位数字）
  name: string; // 房间名称
  creatorId: string; // 创建者ID
  createdAt: Date; // 创建时间
  status: RoomStatus; // 房间状态
  playerLimit: number; // 玩家人数上限（5-10）
  players: RoomPlayer[]; // 房间内玩家
  settings: RoomSettings; // 房间设置
  currentGameId?: string; // 当前进行中的游戏ID
  lastActiveAt: Date; // 最后活跃时间
  isPrivate: boolean; // 是否为私密房间
  password?: string; // 房间密码（如果是私密房间）
  chatEnabled: boolean; // 是否启用聊天
  spectatorMode: boolean; // 是否允许观战
  tags: string[]; // 房间标签
  version: number; // 数据版本号（用于乐观锁）
}

// 房间内玩家信息
interface RoomPlayer {
  userId: string; // 用户ID
  nickname: string; // 用户昵称
  avatarUrl: string; // 头像URL
  isReady: boolean; // 是否准备完毕
  isOnline: boolean; // 是否在线
  joinedAt: Date; // 加入时间
  isHost: boolean; // 是否为房主
  seatIndex: number; // 座位索引
  userSettings?: {
    // 玩家在房间中的个人设置
    preferredRoles?: string[]; // 偏好角色
    autoReady?: boolean; // 自动准备
  };
}

// 房间设置
interface RoomSettings {
  roleConfig: {
    // 角色配置
    enabledRoles: string[]; // 启用的角色列表
    roleDistribution: {
      // 角色分布配置
      [role: string]: number; // 角色名称 -> 数量
    };
  };
  gameConfig: {
    // 游戏配置
    missionRequirements: number[][]; // 每轮任务需要的人数
    voteTimeLimit: number; // 投票时间限制(秒)
    discussionTimeLimit: number; // 讨论时间限制(秒)
    teamSelectionTimeLimit: number; // 选择团队时间限制(秒)
    enableTimer: boolean; // 是否启用计时器
    specialRules?: {
      // 特殊规则
      enableLadyOfLake?: boolean; // 启用湖中仙女
      enableExcalibur?: boolean; // 启用神剑
    };
  };
}

// 房间状态枚举
enum RoomStatus {
  WAITING = "waiting", // 等待玩家加入
  READY = "ready", // 准备开始
  IN_GAME = "in_game", // 游戏进行中
  FINISHED = "finished", // 游戏已结束
  DISBANDED = "disbanded", // 房间已解散
}
```

### 2.2 游戏进程数据模型

游戏进程数据模型捕获游戏当前状态和进展情况。对于阿瓦隆游戏，这包括当前游戏阶段、任务情况、玩家角色等信息。

```typescript
interface GameState {
  _id: ObjectId; // MongoDB文档ID
  gameId: string; // 游戏唯一标识
  roomId: string; // 关联的房间ID
  version: number; // 游戏状态版本(递增)
  createdAt: Date; // 游戏创建时间
  startedAt: Date; // 游戏开始时间
  endedAt?: Date; // 游戏结束时间
  updateSequence: number; // 更新序列号(用于同步)
  players: GamePlayer[]; // 参与游戏的玩家
  currentPhase: GamePhase; // 当前游戏阶段
  round: number; // 当前游戏轮次(1-5)
  votingTrack: number; // 投票轮次(连续不通过计数)
  currentLeaderId: string; // 当前队长ID
  missionResults: boolean[]; // 已完成任务结果[成功,失败,...]
  currentTeam: string[]; // 当前选择的团队(玩家ID列表)
  votes: {
    // 投票记录
    [userId: string]: boolean; // 玩家ID -> 投票结果(赞成/反对)
  };
  missionVotes?: {
    // 任务投票记录(仅任务阶段)
    [userId: string]: boolean; // 玩家ID -> 投票结果(成功/失败)
  };
  winner?: Team; // 胜利方(游戏结束时)
  assassinationTarget?: string; // 刺客刺杀目标(如果有)
  missionRequirements: number[][]; // 每轮任务需要的人数
  failuresRequiredPerMission: number[]; // 每轮任务失败所需票数
  roleDistribution: {
    // 角色分布
    [role: string]: number; // 角色 -> 数量
  };
  events: string[]; // 游戏事件ID引用(按时间顺序)
  isCompleted: boolean; // 游戏是否已完成
  specialRuleState?: {
    // 特殊规则状态
    ladyOfLakeHolder?: string; // 湖中仙女持有者
    excaliburHolder?: string; // 神剑持有者
  };
}

// 游戏中的玩家
interface GamePlayer {
  userId: string; // 用户ID
  nickname: string; // 用户昵称
  avatarUrl: string; // 头像URL
  role: Role; // 分配的角色
  team: Team; // 所属阵营
  isConnected: boolean; // 是否连接中
  seatIndex: number; // 座位索引
  voteHistory: boolean[]; // 投票历史记录
  missionParticipation: {
    // 任务参与记录
    round: number; // 任务轮次
    vote?: boolean; // 任务投票(如果参与)
  }[];
  visibleRoles?: {
    // 可见角色信息(基于角色能力)
    [userId: string]: Role; // 玩家ID -> 角色
  };
}

// 游戏阶段枚举
enum GamePhase {
  ROLE_REVEAL = "role_reveal", // 角色展示
  TEAM_BUILDING = "team_building", // 组队阶段
  TEAM_VOTING = "team_voting", // 投票阶段
  MISSION_EXECUTION = "mission_execution", // 任务执行
  ASSASSINATION = "assassination", // 刺客刺杀
  GAME_END = "game_end", // 游戏结束
}

// 角色枚举
enum Role {
  MERLIN = "merlin", // 梅林
  PERCIVAL = "percival", // 派西维尔
  LOYAL_SERVANT = "loyal_servant", // 忠臣
  ASSASSIN = "assassin", // 刺客
  MORGANA = "morgana", // 莫甘娜
  MORDRED = "mordred", // 莫德雷德
  OBERON = "oberon", // 奥伯伦
}

// 阵营枚举
enum Team {
  GOOD = "good", // 好人阵营
  EVIL = "evil", // 坏人阵营
}
```

### 2.3 游戏事件数据模型

游戏事件是对游戏中发生的所有重要行为的记录，采用事件溯源模式存储。

```typescript
interface GameEvent {
  _id: ObjectId; // MongoDB文档ID
  eventId: string; // 事件唯一标识
  gameId: string; // 关联的游戏ID
  type: GameEventType; // 事件类型
  timestamp: Date; // 事件发生时间
  sequence: number; // 事件序列号
  payload: any; // 事件数据负载
  actorId?: string; // 事件触发者ID(如果适用)
  metadata?: {
    // 元数据
    clientId?: string; // 客户端标识
    version?: number; // 客户端版本
    sessionId?: string; // 会话ID
  };
  snapshots?: {
    // 事件前后的快照引用
    before?: string; // 事件前状态快照ID
    after?: string; // 事件后状态快照ID
  };
}

// 游戏事件类型枚举
enum GameEventType {
  // 游戏生命周期事件
  GAME_CREATED = "game_created",
  GAME_STARTED = "game_started",
  GAME_ENDED = "game_ended",

  // 角色相关事件
  ROLES_ASSIGNED = "roles_assigned",

  // 队伍组建事件
  LEADER_SELECTED = "leader_selected",
  TEAM_PROPOSED = "team_proposed",
  PLAYER_ADDED_TO_TEAM = "player_added_to_team",
  PLAYER_REMOVED_FROM_TEAM = "player_removed_from_team",
  TEAM_CONFIRMED = "team_confirmed",

  // 投票事件
  VOTE_CAST = "vote_cast",
  TEAM_APPROVED = "team_approved",
  TEAM_REJECTED = "team_rejected",

  // 任务事件
  MISSION_STARTED = "mission_started",
  MISSION_VOTE_CAST = "mission_vote_cast",
  MISSION_COMPLETED = "mission_completed",
  MISSION_SUCCESS = "mission_success",
  MISSION_FAIL = "mission_fail",

  // 刺杀事件
  ASSASSINATION_PHASE_STARTED = "assassination_phase_started",
  ASSASSINATION_TARGET_SELECTED = "assassination_target_selected",
  ASSASSINATION_RESULT = "assassination_result",

  // 玩家状态事件
  PLAYER_DISCONNECTED = "player_disconnected",
  PLAYER_RECONNECTED = "player_reconnected",

  // 特殊规则事件
  LADY_OF_LAKE_USED = "lady_of_lake_used",
  EXCALIBUR_USED = "excalibur_used",

  // 系统事件
  PHASE_TIMEOUT = "phase_timeout",
  PHASE_CHANGED = "phase_changed",
  ERROR_OCCURRED = "error_occurred",
}
```

### 2.4 游戏历史记录数据模型

游戏历史记录是对已完成游戏的摘要数据，用于查询和统计分析。

```typescript
interface GameHistory {
  _id: ObjectId; // MongoDB文档ID
  gameId: string; // 游戏唯一标识
  roomId: string; // 关联的房间ID
  startTime: Date; // 游戏开始时间
  endTime: Date; // 游戏结束时间
  duration: number; // 游戏持续时间(秒)
  playerCount: number; // 玩家数量
  players: GameHistoryPlayer[]; // 玩家记录
  winningTeam: Team; // 获胜阵营
  missionResults: boolean[]; // 任务结果[成功,失败,...]
  votingTracks: number[]; // 每轮任务的投票轮次
  assassinationResult?: {
    // 刺杀结果
    assassinId: string; // 刺客ID
    targetId: string; // 目标ID
    success: boolean; // 是否成功
  };
  settings: {
    // 游戏设置
    roleConfig: {
      // 角色配置
      [role: string]: number; // 角色 -> 数量
    };
    specialRules: string[]; // 特殊规则列表
  };
  stats: {
    // 游戏统计数据
    totalVotes: number; // 总投票次数
    rejectedTeams: number; // 被拒绝的团队数
    averageTeamSize: number; // 平均团队大小
    missionSuccessRate: number; // 任务成功率
  };
  events: {
    // 关键事件记录
    type: GameEventType; // 事件类型
    timestamp: Date; // 事件时间
    summary: string; // 事件摘要
  }[];
  replayAvailable: boolean; // 是否可回放
  gameVersion: string; // 游戏版本
}

// 游戏历史中的玩家记录
interface GameHistoryPlayer {
  userId: string; // 用户ID
  nickname: string; // 用户昵称
  role: Role; // 扮演角色
  team: Team; // 所属阵营
  isWinner: boolean; // 是否获胜
  stats: {
    // 个人统计
    teamLeaderCount: number; // 担任队长次数
    missionParticipationCount: number; // 参与任务次数
    votingAccuracy: number; // 投票准确率(投好人团队的比例)
    disconnectionCount: number; // 断线次数
  };
}
```

### 2.5 数据关联关系

阿瓦隆游戏数据模型之间存在以下关联关系：

```plantuml
@startuml
!theme plain
hide circle
skinparam linetype ortho

entity "GameRoom" as room {
  *roomId: string <<PK>>
  --
  *creatorId: string <<FK>>
  *players: RoomPlayer[]
  *settings: RoomSettings
  currentGameId: string <<FK>>
}

entity "GameState" as state {
  *gameId: string <<PK>>
  --
  *roomId: string <<FK>>
  *players: GamePlayer[]
  *events: string[] <<FK>>
}

entity "GameEvent" as event {
  *eventId: string <<PK>>
  --
  *gameId: string <<FK>>
  *actorId: string <<FK>>
}

entity "GameHistory" as history {
  *gameId: string <<PK>>
  --
  *roomId: string <<FK>>
  *players: GameHistoryPlayer[]
}

entity "User" as user {
  *userId: string <<PK>>
}

room "1" -- "0..*" state : contains >
state "1" -- "0..*" event : generates >
state "1" -- "0..1" history : archived as >
user "1" -- "0..*" room : creates >
user "1..*" -- "0..*" room : participates in >
user "1" -- "0..*" event : triggers >

@enduml
```

主要关联：

1. **房间与游戏状态**：一个房间可以关联到零个或一个当前游戏状态，表示该房间中正在进行的游戏。

2. **游戏状态与事件**：一个游戏状态关联多个游戏事件，这些事件按时间顺序记录了游戏的完整历史。

3. **游戏状态与历史记录**：每个完成的游戏状态会生成一条历史记录，用于长期存储和查询。

4. **用户与房间**：用户可以创建多个房间，也可以参与多个房间。

5. **用户与事件**：用户触发游戏中的各种事件。

### 2.6 版本控制与并发处理

为处理并发访问和更新，数据模型中包含以下版本控制机制：

1. **房间版本号**：`Room.version` 用于乐观锁控制，防止并发更新冲突。

2. **游戏状态版本号**：`GameState.version` 跟踪游戏状态的更新序列，确保客户端拥有最新状态。

3. **事件序列号**：`GameEvent.sequence` 确保事件按正确顺序处理和重放。

## 3. 游戏数据存储方案

### 3.1 数据存储服务架构

游戏数据存储服务采用分层架构，结合 MongoDB 和 Redis 提供高性能、可扩展的数据存储解决方案：

```plantuml
@startuml
!theme plain
skinparam componentStyle uml2

package "游戏数据存储服务" {
  [数据访问层] as DAL
  [数据服务层] as DSL
  [数据缓存层] as DCL
  [数据同步层] as DSYL
}

database "MongoDB集群" {
  [主节点] as Primary
  [副本节点1] as Secondary1
  [副本节点2] as Secondary2

  Collections as coll {
    [房间集合]
    [游戏状态集合]
    [游戏事件集合]
    [历史记录集合]
  }
}

database "Redis集群" {
  [主缓存节点] as RedisMaster
  [从缓存节点] as RedisSlave

  [活跃状态缓存] as ActiveState
  [过期管理器] as ExpirationManager
}

DSL --> DAL : 使用
DAL --> Primary : 写入
DAL --> Secondary1 : 读取
DAL --> Secondary2 : 读取
DCL --> RedisMaster : 读写
DCL --> RedisSlave : 读取
DSL --> DCL : 缓存/读取
DSYL <--> DCL : 同步

@enduml
```

主要组件说明：

1. **数据访问层（DAL）**：

   - 提供 MongoDB 数据访问抽象
   - 处理连接池管理
   - 实现集合操作和查询构建

2. **数据服务层（DSL）**：

   - 实现各类数据服务（房间、状态、历史等）
   - 协调缓存和持久化逻辑
   - 处理数据版本控制

3. **数据缓存层（DCL）**：

   - 管理 Redis 缓存
   - 实现缓存策略（LRU、TTL 等）
   - 处理缓存失效和更新

4. **数据同步层（DSYL）**：
   - 确保 MongoDB 和 Redis 数据同步
   - 处理分布式环境下的数据一致性
   - 实现数据变更通知机制

### 3.2 持久化存储策略

阿瓦隆游戏系统使用多层持久化策略，针对不同类型的数据采用不同的存储模式：

#### 3.2.1 房间数据持久化

房间数据采用传统的 CRUD 模式，直接存储在 MongoDB 的房间集合中：

```javascript
// 房间文档示例
{
  _id: ObjectId("60a2b3c4d5e6f7g8h9i0j1k2"),
  roomId: "R1234567890",
  roomCode: "123456",
  name: "阿瓦隆欢乐局",
  creatorId: "U9876543210",
  createdAt: ISODate("2023-06-15T08:30:00Z"),
  status: "waiting",
  playerLimit: 8,
  players: [
    {
      userId: "U9876543210",
      nickname: "游戏大师",
      avatarUrl: "https://example.com/avatar/user1.png",
      isReady: true,
      isOnline: true,
      joinedAt: ISODate("2023-06-15T08:30:00Z"),
      isHost: true,
      seatIndex: 0
    },
    // ...其他玩家
  ],
  settings: {
    roleConfig: {
      enabledRoles: ["merlin", "percival", "loyal_servant", "assassin", "morgana", "mordred"],
      roleDistribution: {
        "merlin": 1,
        "percival": 1,
        "loyal_servant": 3,
        "assassin": 1,
        "morgana": 1,
        "mordred": 1
      }
    },
    gameConfig: {
      missionRequirements: [[2,3,2,3,3]],
      voteTimeLimit: 60,
      discussionTimeLimit: 180,
      teamSelectionTimeLimit: 120,
      enableTimer: true
    }
  },
  version: 12,
  lastActiveAt: ISODate("2023-06-15T08:45:00Z")
}
```

#### 3.2.2 游戏状态持久化

游戏状态采用事件溯源模式，同时结合定期快照：

1. **事件流存储**：

   - 所有改变游戏状态的操作都作为事件存储
   - 事件按顺序记录在游戏事件集合中
   - 每个事件包含足够信息用于重建状态

2. **状态快照**：
   - 系统定期（或在关键节点）创建游戏状态快照
   - 快照存储在游戏状态集合中
   - 快照包含完整的游戏状态，用于快速加载

```javascript
// 游戏事件文档示例
{
  _id: ObjectId("60a2b3c4d5e6f7g8h9i0j1k2"),
  eventId: "E1234567890",
  gameId: "G1234567890",
  type: "TEAM_PROPOSED",
  timestamp: ISODate("2023-06-15T09:05:23Z"),
  sequence: 34,
  payload: {
    leaderId: "U9876543210",
    teamMembers: ["U9876543210", "U8765432109", "U7654321098"]
  },
  actorId: "U9876543210"
}

// 游戏状态快照示例
{
  _id: ObjectId("60a2b3c4d5e6f7g8h9i0j1k2"),
  gameId: "G1234567890",
  version: 34,
  createdAt: ISODate("2023-06-15T09:05:25Z"),
  players: [
    // 玩家数据
  ],
  currentPhase: "TEAM_VOTING",
  round: 2,
  votingTrack: 1,
  currentLeaderId: "U9876543210",
  currentTeam: ["U9876543210", "U8765432109", "U7654321098"],
  // ...其他状态数据
  lastEventId: "E1234567890"
}
```

#### 3.2.3 历史数据持久化

历史数据采用聚合存储模式，将完整游戏结果存储为单个文档：

```javascript
// 游戏历史文档示例
{
  _id: ObjectId("60a2b3c4d5e6f7g8h9i0j1k2"),
  gameId: "G1234567890",
  roomId: "R1234567890",
  startTime: ISODate("2023-06-15T08:50:00Z"),
  endTime: ISODate("2023-06-15T09:30:00Z"),
  duration: 2400,
  players: [
    // 玩家历史记录
  ],
  winningTeam: "GOOD",
  missionResults: [true, true, false, true, true],
  // ...其他历史数据
}
```

### 3.3 缓存设计

游戏数据缓存系统利用 Redis 提供高速数据访问，降低数据库负载：

#### 3.3.1 多级缓存策略

```plantuml
@startuml
!theme plain
skinparam sequenceArrowThickness 2
skinparam roundcorner 5

actor Client
participant "API服务" as API
participant "Redis缓存" as Redis
participant "MongoDB" as Mongo

== 读取操作 ==
Client -> API: 请求游戏状态
API -> Redis: 检查缓存
alt 缓存命中
    Redis --> API: 返回缓存数据
else 缓存未命中
    API -> Mongo: 读取数据库
    Mongo --> API: 返回数据
    API -> Redis: 更新缓存
end
API --> Client: 返回数据

== 写入操作 ==
Client -> API: 更新请求
API -> Redis: 使缓存失效
API -> Mongo: 写入数据库
Mongo --> API: 确认写入
API -> Redis: 更新缓存
API --> Client: 确认更新

@enduml
```

#### 3.3.2 缓存分类

1. **活跃房间缓存**

   - 键格式: `room:{roomId}`
   - 超时: 30 分钟（房间活跃时自动刷新）
   - 存储: 完整房间数据（Hash 结构）

2. **活跃游戏状态缓存**

   - 键格式: `game:{gameId}`
   - 超时: 无（游戏结束时手动删除）
   - 存储: 完整游戏状态（Hash 结构）

3. **游戏事件缓存**

   - 键格式: `events:{gameId}`
   - 实现: Sorted Set (按事件序列号排序)
   - 存储: 最近 100 个事件

4. **用户会话与房间映射**
   - 键格式: `user:room:{userId}`
   - 存储: 用户当前所在房间 ID
   - 用途: 快速定位用户会话

#### 3.3.3 缓存一致性保障

为确保 Redis 缓存与 MongoDB 数据一致性，系统采用以下策略：

1. **写入策略**：先使缓存失效，再更新数据库，最后按需更新缓存（Cache-Aside 模式）

2. **时间戳验证**：缓存条目包含版本号或时间戳，确保不会用旧数据覆盖新数据

3. **定期刷新**：后台任务定期将活跃数据从数据库同步到缓存

4. **分布式锁**：对关键操作使用 Redis 分布式锁确保并发安全性

```javascript
// Redis缓存示例（伪代码）
async function updateGameState(gameId, update) {
  const lockKey = `lock:game:${gameId}`;
  const lock = await redisClient.acquireLock(lockKey, 30000); // 30秒锁

  try {
    // 从数据库读取当前状态
    const currentState = await db.gameStates.findOne({ gameId });

    // 应用更新
    const newState = applyUpdate(currentState, update);
    newState.version = currentState.version + 1;

    // 写入数据库
    await db.gameStates.updateOne(
      { gameId, version: currentState.version },
      { $set: newState }
    );

    // 更新缓存
    await redisClient.hset(`game:${gameId}`, newState);

    return newState;
  } finally {
    // 释放锁
    await lock.release();
  }
}
```

通过以上缓存设计，系统能够承受高并发游戏操作，同时保持数据一致性和高可用性。

## 4. 实时状态同步机制

实时状态同步是阿瓦隆游戏的核心功能，确保所有玩家能够看到一致的游戏状态，并实时响应其他玩家的操作。

### 4.1 状态同步协议

阿瓦隆采用基于 WebSocket 的双向通信协议，结合事件溯源和增量更新机制，实现高效的状态同步：

```plantuml
@startuml
!theme plain
skinparam sequenceArrowThickness 2
skinparam roundcorner 5

participant "客户端A" as ClientA
participant "客户端B" as ClientB
participant "客户端C" as ClientC
participant "WebSocket网关" as WS
participant "状态同步管理器" as Sync
participant "游戏状态服务" as StateService
participant "事件总线" as EventBus
participant "Redis" as Redis
participant "MongoDB" as Mongo

== 初始连接与状态同步 ==
ClientA -> WS: 连接请求(gameId)
WS -> Sync: 请求完整游戏状态
Sync -> Redis: 获取缓存状态
Redis --> Sync: 返回状态数据
Sync --> WS: 完整状态
WS --> ClientA: 初始状态数据

== 游戏操作与状态更新 ==
ClientA -> WS: 提交操作(选择队员)
WS -> StateService: 处理操作请求
StateService -> EventBus: 发布操作事件
EventBus -> Mongo: 存储事件
EventBus -> StateService: 应用事件更新状态
StateService -> Redis: 更新状态缓存
StateService -> Sync: 广播状态变更

Sync -> WS: 推送状态更新
WS ->> ClientA: 状态更新(ACK)
WS ->> ClientB: 状态更新
WS ->> ClientC: 状态更新

@enduml
```

#### 4.1.1 同步消息类型

状态同步协议定义以下核心消息类型：

1. **完整状态(FULL_STATE)**

   ```javascript
   {
     type: "FULL_STATE",
     gameId: "G1234567890",
     version: 42,
     state: {
       // 完整游戏状态对象
     },
     timestamp: 1623744323000
   }
   ```

2. **增量更新(DELTA_UPDATE)**

   ```javascript
   {
     type: "DELTA_UPDATE",
     gameId: "G1234567890",
     fromVersion: 42,
     toVersion: 43,
     changes: [
       {
         path: "currentPhase",
         value: "MISSION_EXECUTION"
       },
       {
         path: "votes.U9876543210",
         value: true
       }
     ],
     eventIds: ["E5678901234"],
     timestamp: 1623744328000
   }
   ```

3. **事件通知(EVENT_NOTIFICATION)**

   ```javascript
   {
     type: "EVENT_NOTIFICATION",
     gameId: "G1234567890",
     events: [
       {
         id: "E5678901234",
         type: "VOTE_CAST",
         actorId: "U9876543210",
         payload: {
           vote: true
         },
         timestamp: 1623744327000
       }
     ],
     stateVersion: 43
   }
   ```

4. **同步请求(SYNC_REQUEST)**
   ```javascript
   {
     type: "SYNC_REQUEST",
     gameId: "G1234567890",
     clientVersion: 40,
     sessionId: "S9876543210"
   }
   ```

#### 4.1.2 优化策略

为提高通信效率，同步协议采用以下优化策略：

1. **增量更新**：

   - 当状态变化较小时，仅发送变化的字段路径和新值
   - 使用 JSON Patch 格式表示变更
   - 客户端根据版本号和变更路径应用更新

2. **批量事件**：

   - 短时间内的多个事件合并为一个状态更新
   - 减少网络往返和客户端处理负担

3. **压缩传输**：

   - 使用 MessagePack 或 CBOR 进行消息序列化
   - 对大型状态对象启用 gzip 压缩
   - WebSocket 二进制传输模式

4. **优先级队列**：
   - 关键状态更新（如游戏阶段变化）优先级高
   - 非关键更新（如计时器）优先级低

### 4.2 断线重连机制

游戏中断线是常见问题，阿瓦隆实现了强大的断线重连机制确保游戏连续性：

```plantuml
@startuml
!theme plain
skinparam stateFontSize 14
skinparam stateArrowThickness 2

[*] --> Connected

state Connected {
  [*] --> Active
  Active --> Inactive : 心跳超时
  Inactive --> Active : 心跳恢复
}

Connected --> Disconnected : 连接断开
Disconnected --> ReconnectionAttempt : 尝试重连

state ReconnectionAttempt {
  [*] --> Authenticating
  Authenticating --> SyncingState : 认证成功
  SyncingState --> [*] : 状态同步完成
}

ReconnectionAttempt --> Connected : 重连成功
ReconnectionAttempt --> PermanentlyDisconnected : 重连失败(超过重试次数)

PermanentlyDisconnected --> [*] : 会话结束

@enduml
```

#### 4.2.1 断线检测

系统通过多层机制检测客户端断线：

1. **WebSocket 心跳**：

   - 客户端每 15 秒发送 PING 消息
   - 服务器回复 PONG 消息
   - 连续 3 次未收到 PING 判定为断线

2. **应用层心跳**：

   - 客户端每 30 秒发送`HEARTBEAT`消息
   - 包含客户端状态版本和时间戳
   - 服务器记录最后活跃时间

3. **状态更新确认**：
   - 客户端必须确认关键状态更新
   - 未收到确认会触发重传机制

#### 4.2.2 会话管理

断线重连依赖会话管理实现状态恢复：

```javascript
// 会话对象示例
{
  sessionId: "S9876543210",
  userId: "U9876543210",
  gameId: "G1234567890",
  connectedAt: 1623744000000,
  lastActiveAt: 1623744300000,
  currentVersion: 45,
  deviceInfo: {
    platform: "iOS",
    version: "14.5",
    network: "WiFi"
  },
  reconnectionToken: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  pendingAcks: ["E5678901234", "E6789012345"]
}
```

会话保持策略：

- 活跃会话存储在 Redis 中，设置 60 分钟 TTL
- 断线后会话保留 30 分钟，允许重连
- 重连时使用会话 ID 和令牌验证身份

#### 4.2.3 状态恢复流程

客户端断线重连后，按以下流程恢复游戏状态：

1. **重连握手**：

   ```javascript
   // 客户端发送
   {
     type: "RECONNECT",
     sessionId: "S9876543210",
     token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
     lastVersion: 42,
     lastEventId: "E5678901234"
   }
   ```

2. **验证会话**：服务器验证会话有效性和重连令牌

3. **判断状态差异**：

   - 如果客户端版本接近当前版本，发送增量更新
   - 如果差异大或客户端版本无效，发送完整状态

4. **恢复游戏状态**：

   ```javascript
   // 服务器响应
   {
     type: "RECONNECT_STATE",
     sessionId: "S9876543210",
     success: true,
     currentVersion: 45,
     updates: [
       // 增量更新或完整状态
     ],
     missedEvents: [
       // 客户端错过的事件
     ]
   }
   ```

5. **恢复确认**：客户端确认状态恢复完成，重新加入游戏

### 4.3 状态一致性保障

在多客户端环境中，确保状态一致性是关键挑战。阿瓦隆采用以下机制保障一致性：

#### 4.3.1 集中式状态管理

系统采用服务器权威模式，所有状态变更必须经过服务器验证：

```plantuml
@startuml
!theme plain
skinparam componentStyle uml2

package "客户端" {
  [客户端状态模型] as ClientState
  [乐观更新处理器] as OptimisticHandler
  [状态冲突解决器] as ConflictResolver
}

package "服务器" {
  [游戏状态服务] as GameState
  [状态验证器] as Validator
  [状态演化引擎] as Evolution
}

ClientState -> OptimisticHandler : 本地操作
OptimisticHandler --> ClientState : 乐观更新
OptimisticHandler -> GameState : 操作请求

GameState -> Validator : 验证操作
Validator -> Evolution : 应用有效操作
Evolution --> GameState : 更新状态
GameState --> ClientState : 确认状态/冲突通知

ConflictResolver -> ClientState : 解决冲突

@enduml
```

#### 4.3.2 版本控制与冲突检测

每个游戏状态包含版本号，用于检测并发冲突：

1. **客户端请求**：包含操作基于的状态版本

   ```javascript
   {
     type: "ACTION",
     gameId: "G1234567890",
     action: "SELECT_TEAM_MEMBER",
     payload: {
       memberId: "U8765432109"
     },
     baseVersion: 42,
     clientId: "C1234567890"
   }
   ```

2. **版本检查**：服务器验证请求基于最新版本

   - 如果版本匹配，处理操作并更新状态
   - 如果版本过期，拒绝操作并返回冲突错误

3. **冲突处理**：

   ```javascript
   {
     type: "CONFLICT",
     gameId: "G1234567890",
     requestId: "R1234567890",
     expectedVersion: 45,
     actualVersion: 42,
     resolution: "REJECTED"
   }
   ```

4. **状态收敛**：客户端收到冲突通知后同步最新状态

#### 4.3.3 事务型操作处理

复杂操作通过事务处理确保原子性：

```javascript
// 伪代码：事务型操作处理
async function processTeamVoting(gameId, votes) {
  // 1. 获取分布式锁
  const lock = await acquireLock(`game:${gameId}:lock`, 30000);

  try {
    // 2. 读取当前状态
    const gameState = await getGameState(gameId);

    // 3. 验证操作合法性
    if (gameState.currentPhase !== "TEAM_VOTING") {
      throw new Error("Invalid game phase for voting");
    }

    // 4. 应用所有投票
    const updatedState = applyVotes(gameState, votes);

    // 5. 检查是否需要阶段转换
    if (isVotingComplete(updatedState)) {
      const votingResult = calculateVotingResult(updatedState);

      if (votingResult.approved) {
        // 团队获批，进入任务执行阶段
        updatePhase(updatedState, "MISSION_EXECUTION");
      } else {
        // 团队被拒，更新投票轨道并选择新队长
        incrementVotingTrack(updatedState);
        selectNextLeader(updatedState);
        updatePhase(updatedState, "TEAM_BUILDING");
      }
    }

    // 6. 持久化更新
    await saveGameState(updatedState);

    // 7. 发布状态变更事件
    await publishStateChange(updatedState);

    return updatedState;
  } finally {
    // 8. 释放锁
    await lock.release();
  }
}
```

通过以上机制，阿瓦隆游戏系统确保多客户端环境下的状态一致性，提供流畅的游戏体验，同时有效处理网络波动和断线情况。

## 5. 事件溯源机制

阿瓦隆游戏采用事件溯源(Event Sourcing)模式作为核心数据管理策略，记录所有改变游戏状态的事件，而不是直接存储当前状态。这种方式提供了完整的游戏历史记录，支持游戏回放、审计和故障恢复等高级功能。

### 5.1 事件设计

游戏事件是系统中所有状态变更的基础，每个事件必须具备自包含性，包含足够信息描述一个状态变更。

#### 5.1.1 事件模型

事件模型遵循以下原则：

- 事件是不可变的（一旦创建永不修改）
- 事件必须按顺序处理
- 每个事件有唯一标识和序列号
- 事件包含完整的上下文信息

```typescript
// 事件基础接口
interface GameEvent {
  eventId: string; // 事件唯一标识
  gameId: string; // 关联的游戏ID
  type: GameEventType; // 事件类型
  timestamp: number; // 事件发生时间戳
  sequence: number; // 事件序列号(游戏内递增)
  actorId?: string; // 触发者ID(如果适用)
  payload: any; // 事件数据负载
  metadata?: any; // 事件元数据
}

// 具体事件示例
interface TeamProposedEvent extends GameEvent {
  type: GameEventType.TEAM_PROPOSED;
  payload: {
    leaderId: string; // 队长ID
    teamMembers: string[]; // 选择的团队成员
    round: number; // 当前回合
    missionIndex: number; // 任务索引
  };
}
```

#### 5.1.2 事件类型分类

阿瓦隆游戏中的事件可分为以下几类：

1. **游戏流程事件**：控制游戏阶段和流程

   - `GAME_CREATED`: 游戏创建
   - `GAME_STARTED`: 游戏开始
   - `PHASE_CHANGED`: 阶段变更
   - `ROUND_STARTED`: 回合开始
   - `GAME_ENDED`: 游戏结束

2. **玩家操作事件**：玩家在游戏中的操作

   - `TEAM_MEMBER_SELECTED`: 队员选择
   - `TEAM_APPROVED`: 团队批准
   - `TEAM_REJECTED`: 团队拒绝
   - `MISSION_VOTE_CAST`: 任务投票
   - `ASSASSINATION_TARGET_SELECTED`: 刺杀目标选择

3. **系统事件**：系统自动触发的事件

   - `LEADER_ASSIGNED`: 队长分配
   - `ROLES_ASSIGNED`: 角色分配
   - `TIMER_EXPIRED`: 计时器过期
   - `MISSION_RESULT_REVEALED`: 任务结果揭示

4. **元事件**：关于其他事件的事件
   - `EVENT_SEQUENCE_CORRUPTED`: 事件序列损坏
   - `STATE_SNAPSHOT_CREATED`: 状态快照创建
   - `HISTORY_ARCHIVED`: 历史归档

#### 5.1.3 事件命名与版本控制

为确保长期维护，事件遵循严格的命名和版本控制规则：

- 事件类型使用动词过去式（如`TEAM_PROPOSED`而非`PROPOSE_TEAM`）
- 事件支持版本标记（`metadata.version`），允许兼容多版本事件
- 关键事件定义不变协议（不允许移除或改变已有字段含义）

### 5.2 事件存储与重放

事件存储是事件溯源的核心基础设施，负责持久化和检索事件序列。

#### 5.2.1 事件存储架构

```plantuml
@startuml
!theme plain
skinparam componentStyle uml2

package "事件基础设施" {
  [事件生产者] as Producer
  [事件总线] as EventBus
  [事件存储服务] as EventStore
  [事件流处理器] as EventProcessor
  [事件投影服务] as Projector
}

database "MongoDB" {
  [事件集合] as EventCollection
  [事件索引] as EventIndex
}

database "Redis" {
  [事件缓存] as EventCache
  [事件流] as EventStream
}

Producer --> EventBus : 发布事件
EventBus --> EventStore : 持久化事件
EventBus --> EventProcessor : 处理事件
EventProcessor --> Projector : 更新视图
EventStore --> EventCollection : 写入
EventStore --> EventCache : 缓存
EventStore --> EventStream : 流式处理
Projector --> EventIndex : 构建索引

@enduml
```

#### 5.2.2 事件存储实现

事件存储使用 MongoDB 和 Redis 实现多层存储：

1. **MongoDB 持久层**：

   ```javascript
   // 事件持久化（伪代码）
   async function persistEvent(event) {
     // 生成事件ID和序列号
     if (!event.eventId) {
       event.eventId = generateUUID();
     }

     // 在事务中更新事件序列并存储事件
     const session = await mongoClient.startSession();
     try {
       session.startTransaction();

       // 获取并递增序列号
       const sequence = await db.sequences.findOneAndUpdate(
         { gameId: event.gameId, type: "event" },
         { $inc: { currentValue: 1 } },
         { returnDocument: "after", session }
       );

       event.sequence = sequence.currentValue;
       event.timestamp = Date.now();

       // 存储事件
       await db.events.insertOne(event, { session });

       await session.commitTransaction();
       return event;
     } catch (error) {
       await session.abortTransaction();
       throw error;
     } finally {
       await session.endSession();
     }
   }
   ```

2. **Redis 缓存层**：

   ```javascript
   // 事件缓存（伪代码）
   async function cacheEvent(event) {
     // 添加到事件流（按游戏ID分组）
     await redisClient.xadd(
       `events:stream:${event.gameId}`,
       "*", // 自动生成ID
       "event",
       JSON.stringify(event)
     );

     // 添加到已排序集合，按序列号排序
     await redisClient.zadd(
       `events:sorted:${event.gameId}`,
       event.sequence,
       event.eventId
     );

     // 限制缓存大小
     await redisClient.zremrangebyrank(
       `events:sorted:${event.gameId}`,
       0,
       -101 // 保留最近100个事件
     );
   }
   ```

#### 5.2.3 事件重放机制

事件重放是从事件流重建状态的过程，用于状态恢复、游戏回放等场景：

```javascript
// 事件重放（伪代码）
async function replayEvents(gameId, fromSequence = 0, toSequence = Infinity) {
  let state = createInitialState();

  // 可选：加载最近的快照作为起点
  if (fromSequence > 0) {
    const snapshot = await findNearestSnapshot(gameId, fromSequence);
    if (snapshot) {
      state = snapshot.state;
      fromSequence = snapshot.sequence + 1;
    }
  }

  // 获取事件流
  const events = await getEventRange(gameId, fromSequence, toSequence);

  // 按序应用每个事件
  for (const event of events) {
    state = applyEvent(state, event);
  }

  return state;
}

// 应用单个事件
function applyEvent(state, event) {
  switch (event.type) {
    case "GAME_STARTED":
      return applyGameStarted(state, event);
    case "TEAM_PROPOSED":
      return applyTeamProposed(state, event);
    case "VOTE_CAST":
      return applyVoteCast(state, event);
    // ...其他事件类型
    default:
      console.warn(`未知事件类型: ${event.type}`);
      return state;
  }
}
```

#### 5.2.4 事件流查询与过滤

系统支持多种方式查询和过滤事件流：

1. **按游戏 ID 查询**：获取特定游戏的所有事件
2. **按序列号范围查询**：重放特定阶段事件
3. **按事件类型查询**：分析特定类型的事件
4. **按时间范围查询**：查看特定时间段内事件

```javascript
// 事件查询示例（伪代码）
async function queryEvents(params) {
  const { gameId, fromSequence, toSequence, eventTypes, startTime, endTime } =
    params;

  let query = { gameId };

  // 序列号范围
  if (fromSequence !== undefined || toSequence !== undefined) {
    query.sequence = {};
    if (fromSequence !== undefined) query.sequence.$gte = fromSequence;
    if (toSequence !== undefined) query.sequence.$lte = toSequence;
  }

  // 事件类型
  if (eventTypes && eventTypes.length > 0) {
    query.type = { $in: eventTypes };
  }

  // 时间范围
  if (startTime !== undefined || endTime !== undefined) {
    query.timestamp = {};
    if (startTime !== undefined) query.timestamp.$gte = startTime;
    if (endTime !== undefined) query.timestamp.$lte = endTime;
  }

  // 执行查询并返回结果
  return await db.events.find(query).sort({ sequence: 1 }).toArray();
}
```

### 5.3 状态重建策略

状态重建是事件溯源系统的核心功能，将事件流转化为可用的游戏状态。

#### 5.3.1 状态计算模型

```plantuml
@startuml
!theme plain
skinparam sequenceArrowThickness 2
skinparam roundcorner 5

participant "状态查询服务" as StateQuery
participant "状态重建服务" as StateBuilder
participant "快照服务" as Snapshot
participant "事件存储" as EventStore
database "状态快照" as SnapshotDB
database "事件数据库" as EventDB

StateQuery -> StateBuilder: 请求游戏状态(gameId)
StateBuilder -> Snapshot: 查找最近快照
Snapshot -> SnapshotDB: 查询快照
SnapshotDB --> Snapshot: 返回快照
Snapshot --> StateBuilder: 快照数据

StateBuilder -> EventStore: 查询快照后事件
EventStore -> EventDB: 查询事件
EventDB --> EventStore: 返回事件
EventStore --> StateBuilder: 事件流

StateBuilder -> StateBuilder: 应用事件流
StateBuilder --> StateQuery: 返回当前状态

@enduml
```

#### 5.3.2 快照策略

为了提高状态重建效率，系统定期创建状态快照：

1. **快照触发条件**：

   - 事件数量达到阈值（如游戏产生了 100 个新事件）
   - 关键阶段变更（如任务完成、回合结束）
   - 定时触发（每 10 分钟）
   - 游戏结束时

2. **快照内容**：

   ```javascript
   // 状态快照结构
   {
     _id: ObjectId("..."),
     gameId: "G1234567890",
     createdAt: ISODate("2023-06-15T09:30:00Z"),
     sequence: 145,  // 快照对应的事件序列号
     lastEventId: "E1234567890",
     state: {
       // 完整游戏状态
       // ...
     },
     metadata: {
       version: "1.0",
       source: "snapshot_service",
       compressionType: "none"
     }
   }
   ```

3. **快照压缩**：
   - 大型状态快照使用压缩存储
   - 支持增量快照（只存储与上一快照的差异）
   - 定期清理旧快照（保留关键点快照）

#### 5.3.3 并发重建优化

对于活跃游戏，多个客户端可能同时请求状态重建，为提高效率：

1. **状态缓存**：

   - 缓存热门游戏的当前状态
   - 使用版本号确保缓存有效

2. **批处理重建**：

   - 合并短时间内的多个重建请求
   - 一次重建，多次分发结果

3. **渐进式加载**：
   - 先返回基本状态
   - 再加载完整细节（例如历史信息）

```javascript
// 优化状态重建（伪代码）
async function getOptimizedState(gameId) {
  // 1. 检查缓存
  const cachedState = await redisClient.get(`game:state:${gameId}`);
  if (cachedState) {
    return JSON.parse(cachedState);
  }

  // 2. 获取重建锁或等待已有重建
  const rebuildLock = `game:rebuild:${gameId}`;
  if (await redisClient.exists(rebuildLock)) {
    // 已有重建进行中，等待其完成
    return new Promise((resolve) => {
      const checkInterval = setInterval(async () => {
        const newState = await redisClient.get(`game:state:${gameId}`);
        if (newState) {
          clearInterval(checkInterval);
          resolve(JSON.parse(newState));
        }
      }, 100);
    });
  }

  // 3. 获取锁并重建
  await redisClient.set(rebuildLock, "1", "EX", 30); // 30秒锁
  try {
    // 查找最近快照
    const snapshot = await getLatestSnapshot(gameId);
    let state = snapshot ? snapshot.state : createInitialState();
    let fromSequence = snapshot ? snapshot.sequence + 1 : 0;

    // 应用后续事件
    const events = await getEventsAfterSequence(gameId, fromSequence);
    for (const event of events) {
      state = applyEvent(state, event);
    }

    // 缓存结果
    await redisClient.set(
      `game:state:${gameId}`,
      JSON.stringify(state),
      "EX",
      300 // 5分钟缓存
    );

    return state;
  } finally {
    // 释放锁
    await redisClient.del(rebuildLock);
  }
}
```

通过事件溯源机制，阿瓦隆游戏系统实现了高度的可追溯性和灵活性，为游戏回放、状态恢复和数据分析提供了坚实基础。

## 6. 游戏数据 API

阿瓦隆游戏数据 API 提供全面的数据访问接口，允许客户端创建、读取、更新和删除游戏相关数据，同时支持实时状态同步、历史查询和游戏回放功能。

### 6.1 房间管理 API

房间管理 API 提供对游戏房间生命周期的完整控制，包括创建、配置、加入、退出和解散房间。

#### 6.1.1 REST API 端点

| 方法   | 路径                       | 描述               | 权限       |
| ------ | -------------------------- | ------------------ | ---------- |
| POST   | /api/rooms                 | 创建新房间         | 已认证用户 |
| GET    | /api/rooms                 | 查询房间列表       | 已认证用户 |
| GET    | /api/rooms/{roomId}        | 获取房间详情       | 房间成员   |
| PATCH  | /api/rooms/{roomId}        | 更新房间设置       | 房主       |
| POST   | /api/rooms/{roomId}/join   | 加入房间           | 已认证用户 |
| POST   | /api/rooms/{roomId}/leave  | 离开房间           | 房间成员   |
| POST   | /api/rooms/{roomId}/start  | 开始游戏           | 房主       |
| DELETE | /api/rooms/{roomId}        | 解散房间           | 房主       |
| GET    | /api/rooms/code/{roomCode} | 通过邀请码查找房间 | 已认证用户 |

#### 6.1.2 API 示例

1. **创建房间**

   ```http
   POST /api/rooms HTTP/1.1
   Content-Type: application/json
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

   {
     "name": "阿瓦隆精英局",
     "playerLimit": 8,
     "isPrivate": true,
     "settings": {
       "roleConfig": {
         "enabledRoles": ["merlin", "percival", "loyal_servant", "assassin", "morgana", "mordred"],
         "roleDistribution": {
           "merlin": 1,
           "percival": 1,
           "loyal_servant": 3,
           "assassin": 1,
           "morgana": 1,
           "mordred": 1
         }
       },
       "gameConfig": {
         "missionRequirements": [[2,3,2,3,3]],
         "voteTimeLimit": 60,
         "enableTimer": true
       }
     }
   }
   ```

   响应:

   ```json
   {
     "success": true,
     "data": {
       "roomId": "R1234567890",
       "roomCode": "123456",
       "name": "阿瓦隆精英局",
       "creatorId": "U9876543210",
       "createdAt": "2023-06-15T08:30:00Z",
       "status": "waiting",
       "playerLimit": 8,
       "players": [
         {
           "userId": "U9876543210",
           "nickname": "游戏大师",
           "avatarUrl": "https://example.com/avatar/user1.png",
           "isReady": false,
           "isOnline": true,
           "joinedAt": "2023-06-15T08:30:00Z",
           "isHost": true,
           "seatIndex": 0
         }
       ],
       "settings": {
         // 同请求内容
       },
       "isPrivate": true
     }
   }
   ```

2. **查询房间列表**

   ```http
   GET /api/rooms?status=waiting&limit=10&offset=0 HTTP/1.1
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

   响应:

   ```json
   {
     "success": true,
     "data": {
       "rooms": [
         {
           "roomId": "R1234567890",
           "name": "阿瓦隆精英局",
           "creatorId": "U9876543210",
           "status": "waiting",
           "playerCount": 1,
           "playerLimit": 8,
           "createdAt": "2023-06-15T08:30:00Z",
           "isPrivate": true
         }
         // 更多房间
       ],
       "total": 42,
       "offset": 0,
       "limit": 10
     }
   }
   ```

#### 6.1.3 WebSocket 事件

房间状态变更通过 WebSocket 实时推送给客户端:

| 事件类型             | 描述             | 数据内容               |
| -------------------- | ---------------- | ---------------------- |
| ROOM_UPDATED         | 房间信息更新     | 更新后的房间信息       |
| PLAYER_JOINED        | 新玩家加入       | 加入的玩家信息         |
| PLAYER_LEFT          | 玩家离开         | 离开的玩家信息         |
| PLAYER_READY_CHANGED | 玩家准备状态变更 | 玩家 ID 和新的准备状态 |
| GAME_STARTED         | 游戏开始         | 游戏 ID 和初始信息     |
| ROOM_DISBANDED       | 房间解散         | 房间 ID 和原因         |

```javascript
// WebSocket 房间更新事件示例
{
  "type": "ROOM_UPDATED",
  "timestamp": 1623744360000,
  "data": {
    "roomId": "R1234567890",
    "updateType": "SETTINGS_CHANGED",
    "changes": {
      "settings.gameConfig.voteTimeLimit": 45
    },
    "updatedBy": "U9876543210"
  }
}
```

### 6.2 游戏状态 API

游戏状态 API 提供游戏进程中的状态访问和操作能力，主要通过 WebSocket 实现实时交互。

#### 6.2.1 REST API 端点

| 方法 | 路径                       | 描述           | 权限       |
| ---- | -------------------------- | -------------- | ---------- |
| GET  | /api/games/{gameId}        | 获取游戏状态   | 游戏参与者 |
| GET  | /api/games/{gameId}/events | 获取游戏事件流 | 游戏参与者 |
| POST | /api/games/{gameId}/pause  | 暂停游戏       | 房主       |
| POST | /api/games/{gameId}/resume | 恢复游戏       | 房主       |
| POST | /api/games/{gameId}/abort  | 中止游戏       | 房主       |

#### 6.2.2 WebSocket 操作

游戏中的所有操作通过 WebSocket 连接实现:

1. **连接游戏会话**

   ```javascript
   // 客户端连接请求
   {
     "type": "CONNECT_GAME",
     "gameId": "G1234567890",
     "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
     "clientInfo": {
       "platform": "iOS",
       "version": "1.2.0",
       "screen": "375x812"
     }
   }
   ```

   服务器响应:

   ```javascript
   {
     "type": "CONNECT_GAME_RESULT",
     "success": true,
     "sessionId": "S9876543210",
     "timestamp": 1623744400000,
     "gameState": {
       // 完整游戏状态
     }
   }
   ```

2. **游戏操作**

   ```javascript
   // 选择团队成员操作
   {
     "type": "GAME_ACTION",
     "action": "SELECT_TEAM_MEMBER",
     "gameId": "G1234567890",
     "sessionId": "S9876543210",
     "payload": {
       "targetId": "U8765432109"
     },
     "messageId": "M1234567890",
     "timestamp": 1623744450000
   }
   ```

   操作确认:

   ```javascript
   {
     "type": "ACTION_RESULT",
     "success": true,
     "messageId": "M1234567890",
     "resultCode": "SUCCESS",
     "timestamp": 1623744451000
   }
   ```

#### 6.2.3 状态同步事件

游戏状态变更通过 WebSocket 推送给所有玩家:

| 事件类型           | 描述         | 数据内容                   |
| ------------------ | ------------ | -------------------------- |
| GAME_STATE_UPDATED | 游戏状态更新 | 更新类型和状态变更         |
| PHASE_CHANGED      | 游戏阶段变更 | 新阶段信息                 |
| TIMER_UPDATED      | 计时器更新   | 剩余时间                   |
| VOTE_SUBMITTED     | 投票提交     | 投票玩家和投票类型         |
| MISSION_RESULT     | 任务结果公布 | 成功/失败及相关统计        |
| ROLE_REVEALED      | 角色信息公布 | 玩家 ID 和角色(游戏结束时) |
| GAME_ENDED         | 游戏结束     | 获胜阵营和结束原因         |

```javascript
// 阶段变更事件示例
{
  "type": "PHASE_CHANGED",
  "gameId": "G1234567890",
  "fromPhase": "TEAM_BUILDING",
  "toPhase": "TEAM_VOTING",
  "round": 2,
  "data": {
    "leaderId": "U9876543210",
    "selectedTeam": ["U9876543210", "U8765432109", "U7654321098"],
    "votingTimeLimit": 60,
    "votingEndTime": 1623744510000
  },
  "version": 45,
  "timestamp": 1623744450000
}
```

### 6.3 历史数据 API

历史数据 API 提供对已完成游戏的查询和分析功能。

#### 6.3.1 REST API 端点

| 方法 | 路径                              | 描述             | 权限        |
| ---- | --------------------------------- | ---------------- | ----------- |
| GET  | /api/history/games                | 查询历史游戏列表 | 已认证用户  |
| GET  | /api/history/games/{gameId}       | 获取历史游戏详情 | 游戏参与者  |
| GET  | /api/history/users/{userId}/games | 查询用户历史游戏 | 本人/管理员 |
| GET  | /api/history/games/{gameId}/stats | 获取游戏统计数据 | 游戏参与者  |
| GET  | /api/history/users/{userId}/stats | 获取用户游戏统计 | 本人/管理员 |

#### 6.3.2 API 示例

1. **查询历史游戏**

   ```http
   GET /api/history/games?limit=20&offset=0&winningTeam=GOOD HTTP/1.1
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

   响应:

   ```json
   {
     "success": true,
     "data": {
       "games": [
         {
           "gameId": "G1234567890",
           "roomId": "R1234567890",
           "startTime": "2023-06-15T08:50:00Z",
           "endTime": "2023-06-15T09:30:00Z",
           "duration": 2400,
           "playerCount": 8,
           "winningTeam": "GOOD",
           "missionResults": [true, true, false, true, true]
         }
         // 更多游戏
       ],
       "total": 156,
       "offset": 0,
       "limit": 20
     }
   }
   ```

2. **获取用户游戏统计**

   ```http
   GET /api/history/users/U9876543210/stats HTTP/1.1
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

   响应:

   ```json
   {
     "success": true,
     "data": {
       "userId": "U9876543210",
       "totalGames": 42,
       "wins": 28,
       "losses": 14,
       "winRate": 0.67,
       "roleStats": {
         "merlin": {
           "count": 8,
           "wins": 7,
           "winRate": 0.88
         },
         "assassin": {
           "count": 6,
           "wins": 2,
           "winRate": 0.33
         }
         // 其他角色
       },
       "teamStats": {
         "GOOD": {
           "count": 25,
           "wins": 20,
           "winRate": 0.8
         },
         "EVIL": {
           "count": 17,
           "wins": 8,
           "winRate": 0.47
         }
       },
       "leaderStats": {
         "proposalsCount": 37,
         "approvalRate": 0.73
       },
       "missionStats": {
         "participationCount": 78,
         "successRate": 0.82
       }
     }
   }
   ```

### 6.4 游戏回放 API

游戏回放 API 提供游戏过程的完整回放功能，支持从任意时间点开始回放，并提供进度控制。

#### 6.4.1 REST API 端点

| 方法 | 路径                                 | 描述               | 权限       |
| ---- | ------------------------------------ | ------------------ | ---------- |
| GET  | /api/replay/games/{gameId}/metadata  | 获取回放元数据     | 游戏参与者 |
| GET  | /api/replay/games/{gameId}/events    | 获取回放事件流     | 游戏参与者 |
| GET  | /api/replay/games/{gameId}/snapshots | 获取状态快照       | 游戏参与者 |
| GET  | /api/replay/games/{gameId}/state     | 获取特定时间点状态 | 游戏参与者 |

#### 6.4.2 API 示例

1. **获取回放元数据**

   ```http
   GET /api/replay/games/G1234567890/metadata HTTP/1.1
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

   响应:

   ```json
   {
     "success": true,
     "data": {
       "gameId": "G1234567890",
       "startTime": "2023-06-15T08:50:00Z",
       "endTime": "2023-06-15T09:30:00Z",
       "duration": 2400,
       "totalEvents": 187,
       "keyMoments": [
         {
           "sequence": 45,
           "timestamp": 1623744600000,
           "description": "第一次任务完成 - 成功",
           "type": "MISSION_COMPLETED"
         },
         {
           "sequence": 92,
           "timestamp": 1623745200000,
           "description": "第三次任务完成 - 失败",
           "type": "MISSION_COMPLETED"
         }
         // 更多关键时刻
       ],
       "snapshotPoints": [0, 50, 100, 150]
     }
   }
   ```

2. **获取特定时间点状态**

   ```http
   GET /api/replay/games/G1234567890/state?sequence=92 HTTP/1.1
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

   响应:

   ```json
   {
     "success": true,
     "data": {
       "gameId": "G1234567890",
       "sequence": 92,
       "timestamp": 1623745200000,
       "state": {
         // 该时间点的完整游戏状态
       },
       "visibleRoles": true // 回放时可以看到所有角色
     }
   }
   ```

#### 6.4.3 回放控制和优化

为提供流畅的回放体验，API 包括以下优化设计:

1. **分段加载**：

   - 事件流按时间段分批次加载
   - 使用 HTTP Range 请求加载大型事件流
   - 支持增量加载和预加载

2. **快照与细节平衡**：

   - 先加载关键快照和完整结果
   - 按需加载完整细节和过程
   - 客户端缓存已加载的事件和状态

3. **回放控制**：
   - 支持暂停、倍速播放和时间跳转
   - 提供关键时刻标记和直接跳转
   - 允许特定角色视角切换

通过这套完整的 API 体系，阿瓦隆游戏数据系统提供了全面的数据访问和操作能力，满足了游戏运行、数据分析和历史查询的各种需求。

## 7. 数据备份与恢复

阿瓦隆游戏数据的备份与恢复机制是保障系统可靠性和数据安全的重要组成部分，通过多层次的备份和灵活的恢复机制确保游戏数据的完整性和可用性。

### 7.1 备份策略

系统采用分级备份策略，针对不同重要性的数据设定不同的备份频率和保留策略：

```plantuml
@startuml
!theme plain
skinparam backgroundcolor transparent
skinparam componentStyle uml2

package "备份类型" {
  [完整备份] as FB
  [增量备份] as IB
  [差异备份] as DB
  [事件流备份] as EB
  [实时复制] as RC
}

package "数据分类" {
  [核心游戏数据] as CoreData
  [历史记录数据] as HistoryData
  [统计分析数据] as StatsData
  [日志与审计] as LogData
}

FB --> CoreData : 每日
IB --> CoreData : 每4小时
DB --> CoreData : 每12小时
RC --> CoreData : 实时

FB --> HistoryData : 每周
IB --> HistoryData : 每日
DB --> HistoryData : 每3天

FB --> StatsData : 每周
DB --> StatsData : 每3天

EB --> LogData : 连续
FB --> LogData : 每周

@enduml
```

#### 7.1.1 核心游戏数据备份

核心游戏数据包括活跃房间、进行中的游戏状态和最近游戏事件，采用以下备份策略：

1. **实时复制**：

   - MongoDB 副本集提供实时数据复制
   - 至少 3 个节点（主节点+2 个副本节点）
   - 强一致性写入配置（majority write concern）

2. **定时备份**：

   - 每日一次完整备份（凌晨 3 点）
   - 每 4 小时一次增量备份
   - 每 12 小时一次差异备份
   - 备份保留策略：完整备份保留 30 天，增量备份保留 7 天

3. **操作日志**：
   - MongoDB oplog 持续备份
   - 支持时间点恢复（point-in-time recovery）
   - 保留最近 72 小时的操作日志

#### 7.1.2 历史数据备份

历史数据包括已完成游戏的记录和统计信息，采用以下备份策略：

1. **定期备份**：

   - 每周一次完整备份
   - 每日一次增量备份
   - 备份保留策略：完整备份保留 90 天，增量备份保留 30 天

2. **归档处理**：

   - 超过 90 天的历史数据压缩归档
   - 归档数据转移至低成本存储
   - 每季度归档一次，永久保存

3. **数据冷热分离**：
   - 热数据（最近 30 天）存放在高性能存储
   - 温数据（30-90 天）存放在标准存储
   - 冷数据（>90 天）存放在归档存储

#### 7.1.3 备份存储与安全

备份数据的存储和安全保障措施：

1. **多地域存储**：

   - 主备份存储在与生产环境同地域的存储服务
   - 次级备份复制到备用地域
   - 关键备份导出至第三方云存储

2. **加密保护**：

   - 备份数据静态加密（AES-256）
   - 传输过程 TLS 加密
   - 密钥管理与轮转策略

3. **访问控制**：
   - 基于角色的备份访问控制
   - 备份操作审计日志
   - 最小权限原则

```javascript
// 备份配置示例
const backupConfig = {
  coreData: {
    full: {
      schedule: "0 3 * * *", // 每日凌晨3点
      retention: 30, // 保留30天
      encryption: true, // 启用加密
      destinations: ["primary", "secondary"],
    },
    incremental: {
      schedule: "0 */4 * * *", // 每4小时
      retention: 7, // 保留7天
      baseBackup: "latest-full", // 基于最新完整备份
    },
    differential: {
      schedule: "0 */12 * * *", // 每12小时
      retention: 14, // 保留14天
      baseBackup: "latest-full", // 基于最新完整备份
    },
  },
  historyData: {
    full: {
      schedule: "0 2 * * 0", // 每周日凌晨2点
      retention: 90, // 保留90天
      compression: true, // 启用压缩
      coldStorage: {
        afterDays: 30, // 30天后移至冷存储
        tier: "standard",
      },
    },
    incremental: {
      schedule: "0 2 * * 1-6", // 每周一至六凌晨2点
      retention: 30, // 保留30天
      baseBackup: "latest-full",
    },
  },
};
```

### 7.2 快照机制

除常规备份外，系统还利用快照机制提供更灵活的数据保护：

#### 7.2.1 游戏状态快照

游戏进行过程中的状态快照策略：

1. **自动快照触发点**：

   - 每个游戏回合结束时
   - 每次关键操作完成后（如任务完成）
   - 达到事件数量阈值时（如每 50 个事件）
   - 定时触发（如每 5 分钟）

2. **快照内容与格式**：

   - 完整游戏状态对象
   - 关联的最后事件 ID 和序列号
   - 快照版本号和时间戳
   - 快照元数据（创建原因、创建者等）

3. **差异快照**：
   - 仅存储与上一快照的差异
   - 使用 JSON Patch 格式记录变更
   - 每 5 个差异快照合并为一个完整快照

#### 7.2.2 数据库快照

针对 MongoDB 数据库的快照策略：

1. **数据库快照类型**：

   - 文件系统级别快照（依赖存储系统）
   - MongoDB 内置快照功能
   - 集合级别逻辑快照

2. **快照调度**：

   - 游戏高峰期前自动创建（如每日晚间 6 点）
   - 系统维护操作前手动创建
   - 重大版本升级前创建

3. **快照管理**：
   - 快照命名约定：`avalon-{env}-{date}-{type}`
   - 快照自动过期策略（开发环境 24 小时，生产环境 7 天）
   - 快照状态监控和告警

```javascript
// 状态快照创建示例（伪代码）
async function createGameStateSnapshot(gameId, reason) {
  // 获取当前游戏状态
  const currentState = await gameStateService.getState(gameId);

  // 获取最后事件信息
  const lastEvent = await eventService.getLastEvent(gameId);

  // 创建快照对象
  const snapshot = {
    gameId,
    createdAt: new Date(),
    sequence: lastEvent.sequence,
    lastEventId: lastEvent.eventId,
    state: currentState,
    reason: reason,
    version: currentState.version,
    metadata: {
      creator: "snapshot_service",
      triggerType: reason,
      gamePhase: currentState.currentPhase,
    },
  };

  // 存储快照
  await db.snapshots.insertOne(snapshot);

  // 更新快照索引
  await redisClient.zadd(
    `game:${gameId}:snapshots`,
    lastEvent.sequence,
    snapshot._id.toString()
  );

  return snapshot;
}
```

### 7.3 数据恢复流程

系统提供多种恢复机制，应对不同类型的数据丢失或损坏情况：

#### 7.3.1 灾难恢复流程

针对严重故障的完整恢复流程：

```plantuml
@startuml
!theme plain
skinparam activityBackgroundColor white
skinparam activityBorderColor black
skinparam activityDiamondBackgroundColor white
skinparam activityDiamondBorderColor black
skinparam activityArrowColor black

start
:检测到严重数据问题;
:启动灾难恢复流程;
:通知运维团队和管理层;

if (问题是否影响全局数据?) then (是)
  :停止所有游戏服务;
  :识别最近有效的完整备份;
  :恢复数据库到最近完整备份点;
  :应用增量/差异备份;
  :重放操作日志至目标时间点;
else (否)
  :鉴别受影响的数据范围;
  if (是否只影响特定游戏?) then (是)
    :隔离受影响的游戏;
    :从最近快照恢复特定游戏;
    :重建游戏状态;
  else (否)
    :标识受影响的集合/文档;
    :执行选择性恢复;
  endif
endif

:验证数据一致性;
if (验证是否通过?) then (是)
  :重新激活相关服务;
  :通知用户恢复完成;
else (否)
  :标记问题点;
  :尝试替代恢复方案;
  goto 验证数据一致性;
endif

:执行恢复报告;
:更新灾难恢复计划;
stop
@enduml
```

#### 7.3.2 游戏状态恢复机制

针对单个游戏状态问题的恢复流程：

1. **事件重放恢复**：

   - 加载最近的游戏状态快照
   - 检索快照后的所有事件
   - 按序重放事件重建状态
   - 验证最终状态的一致性

2. **时间点恢复**：

   - 选择目标恢复时间点
   - 找到该时间点前的最近快照
   - 应用该时间点前的所有事件
   - 将游戏状态回滚到指定时刻

3. **部分状态修复**：
   - 识别损坏的状态部分
   - 从快照或事件中提取正确数据
   - 仅更新受影响的状态字段
   - 记录人工干预操作日志

```javascript
// 游戏状态恢复示例（伪代码）
async function recoverGameState(gameId, options) {
  const { targetTime, targetSequence, useSnapshot = true } = options;

  let baseState, startSequence;

  // 如果使用快照，查找合适的起点快照
  if (useSnapshot) {
    const snapshot = await findSuitableSnapshot(
      gameId,
      targetSequence || targetTime
    );
    if (snapshot) {
      baseState = snapshot.state;
      startSequence = snapshot.sequence + 1;
      console.log(`从快照开始恢复，序列号: ${startSequence}`);
    } else {
      baseState = createInitialState(gameId);
      startSequence = 0;
      console.log(`没有找到合适快照，从初始状态恢复`);
    }
  } else {
    baseState = createInitialState(gameId);
    startSequence = 0;
    console.log(`不使用快照，从初始状态恢复`);
  }

  // 查询需要重放的事件
  const endCondition = targetSequence
    ? { sequence: { $lte: targetSequence } }
    : { timestamp: { $lte: targetTime.getTime() } };

  const events = await db.events
    .find({
      gameId,
      sequence: { $gte: startSequence },
      ...endCondition,
    })
    .sort({ sequence: 1 })
    .toArray();

  console.log(`找到 ${events.length} 个需要重放的事件`);

  // 重放事件
  let currentState = baseState;
  for (const event of events) {
    currentState = applyEvent(currentState, event);
    console.log(`应用事件: ${event.type}, 序列号: ${event.sequence}`);
  }

  // 返回恢复的状态
  return {
    recoveredState: currentState,
    baseSnapshotSequence: startSequence > 0 ? startSequence - 1 : null,
    appliedEvents: events.length,
    finalSequence:
      events.length > 0 ? events[events.length - 1].sequence : startSequence,
  };
}
```

#### 7.3.3 恢复验证与测试

为确保恢复机制可靠，系统实施以下验证措施：

1. **定期恢复演练**：

   - 每月在测试环境执行完整恢复演练
   - 随机选择生产备份进行恢复测试
   - 定期验证快照恢复准确性

2. **恢复时间目标(RTO)**：

   - 单游戏状态恢复：<5 分钟
   - 单集合恢复：<30 分钟
   - 完整数据库恢复：<4 小时

3. **恢复点目标(RPO)**：
   - 核心游戏数据：<5 分钟数据损失
   - 历史统计数据：<1 小时数据损失
   - 归档数据：<24 小时数据损失

通过这些全面的备份与恢复机制，阿瓦隆游戏系统能够应对各种数据灾难情景，确保游戏数据的安全性和可靠性。

## 8. 高并发与性能优化

阿瓦隆游戏系统在活跃时段可能面临高并发访问压力，尤其是在游戏高峰期和热门活动期间。本节介绍系统的并发处理策略和性能优化方案。

### 8.1 数据库优化

MongoDB 数据库优化是提升系统整体性能的关键环节：

#### 8.1.1 索引优化

针对阿瓦隆游戏数据的访问模式，设计以下索引策略：

```javascript
// 房间集合索引
db.rooms.createIndex({ roomId: 1 }, { unique: true });
db.rooms.createIndex({ roomCode: 1 }, { unique: true });
db.rooms.createIndex({ status: 1, createdAt: -1 }); // 按状态查询房间列表
db.rooms.createIndex({ "players.userId": 1 }); // 查询用户参与的房间
db.rooms.createIndex({ creatorId: 1, createdAt: -1 }); // 查询用户创建的房间
db.rooms.createIndex({ lastActiveAt: -1 }); // TTL索引，用于清理长期不活跃房间

// 游戏事件集合索引
db.events.createIndex({ gameId: 1, sequence: 1 }, { unique: true }); // 主要查询路径
db.events.createIndex({ gameId: 1, timestamp: 1 }); // 按时间查询事件
db.events.createIndex({ gameId: 1, type: 1, timestamp: 1 }); // 按类型查询事件
db.events.createIndex({ actorId: 1, timestamp: -1 }); // 查询用户操作历史

// 游戏状态集合索引
db.gameStates.createIndex({ gameId: 1 }, { unique: true });
db.gameStates.createIndex({ roomId: 1 }); // 按房间查询游戏
db.gameStates.createIndex({ "players.userId": 1 }); // 查询用户参与的游戏
db.gameStates.createIndex({ updatedAt: -1 }); // 最近更新的游戏

// 游戏历史集合索引
db.gameHistory.createIndex({ gameId: 1 }, { unique: true });
db.gameHistory.createIndex({ roomId: 1, endTime: -1 });
db.gameHistory.createIndex({ "players.userId": 1, endTime: -1 }); // 用户游戏历史
db.gameHistory.createIndex({ endTime: -1 }); // 最近结束的游戏
db.gameHistory.createIndex({ winningTeam: 1, endTime: -1 }); // 按阵营胜率统计
```

#### 8.1.2 分片与分区

随着数据量增长，采用以下分片策略：

1. **房间集合分片**：

   - 分片键：`{ createdAt: 1 }`（按创建时间分片）
   - 分片区域：按季度或月份定义分片区域
   - 优势：均匀分布写入，避免热点

2. **事件集合分片**：

   - 分片键：`{ gameId: 1, sequence: 1 }`（按游戏分布）
   - 特点：同一游戏的事件保持在同一分片
   - 优化：使用标签感知分片，将活跃游戏放在高性能节点

3. **历史数据分区**：
   - 按时间范围水平分区（每月一个集合）
   - 集合命名：`gameHistory_202306`（年月格式）
   - 查询时使用集合视图整合所有分区数据

```javascript
// 分片配置示例
sh.shardCollection("avalon.rooms", { createdAt: 1 });
sh.shardCollection("avalon.events", { gameId: 1, sequence: 1 });

// 为活跃游戏添加标签感知分片
sh.addTagRange(
  "avalon.events",
  { gameId: MinKey, sequence: MinKey },
  { gameId: MaxKey, sequence: MaxKey },
  "active"
);

// 为历史集合创建按月视图
db.createView(
  "gameHistoryView",
  [
    "gameHistory_202301",
    "gameHistory_202302",
    // ...更多月份集合
  ],
  []
);
```

#### 8.1.3 读写分离

实现 MongoDB 的读写分离策略：

1. **写入策略**：

   - 所有写入操作路由到主节点
   - 使用批量写入减少操作次数
   - 非关键写入使用无确认模式（w: 0）提高吞吐

2. **读取策略**：

   - 默认查询路由到从节点（secondary reads）
   - 实时性要求高的查询使用主节点
   - 设置最大可接受延迟（maxStalenessSeconds）

3. **一致性设置**：
   - 关键操作使用 majority 读写关注
   - 非关键操作使用 local 读写关注
   - 为相关操作设置读取优先级

```javascript
// 读写分离配置（伪代码）
const writeConcern = {
  critical: { w: "majority", j: true, wtimeout: 5000 },
  normal: { w: 1, j: false, wtimeout: 2000 },
  bulk: { w: 0 },
};

const readPreference = {
  critical: ReadPreference.PRIMARY,
  normal: ReadPreference.SECONDARY_PREFERRED,
  analytics: ReadPreference.SECONDARY,
  reporting: new ReadPreference("secondary", [{ maxStalenessSeconds: 120 }]),
};

// 使用场景
async function getGameState(gameId, importance = "normal") {
  return await db.gameStates.findOne(
    { gameId },
    { readPreference: readPreference[importance] }
  );
}
```

### 8.2 缓存策略

系统采用多层缓存策略，减轻数据库负担并提升响应速度：

#### 8.2.1 Redis 缓存架构

整体缓存架构设计：

```plantuml
@startuml
!theme plain
skinparam componentStyle uml2
skinparam backgroundColor transparent

package "缓存层" {
  [数据缓存] as DataCache
  [查询缓存] as QueryCache
  [会话缓存] as SessionCache
  [限流缓存] as RateLimit
}

database "Redis集群" {
  [主数据节点] as Redis1
  [复制节点1] as Redis2
  [复制节点2] as Redis3

  node "特殊功能节点" {
    [发布订阅节点] as RedisPubSub
    [排行榜节点] as RedisLeaderboard
  }
}

DataCache --> Redis1
QueryCache --> Redis1
SessionCache --> Redis1
RateLimit --> Redis3

@enduml
```

#### 8.2.2 数据缓存策略

不同类型数据的缓存策略：

1. **房间数据缓存**：

   - 键格式：`room:{roomId}`
   - 存储形式：Hash 结构
   - 过期策略：活跃房间 30 分钟，闲置房间 10 分钟
   - 更新策略：写透（Write-Through）

2. **游戏状态缓存**：

   - 键格式：`game:{gameId}`
   - 存储形式：String（序列化 JSON）
   - 过期策略：游戏进行中无过期，结束后 30 分钟
   - 更新策略：写回（Write-Back）+ 定期刷新

3. **用户上下文缓存**：

   - 键格式：`user:{userId}:context`
   - 存储形式：Hash 结构
   - 内容：用户当前房间、游戏状态、会话信息
   - 过期策略：用户活跃时间+15 分钟

4. **查询结果缓存**：
   - 键格式：`query:{hash}` (hash=查询参数哈希)
   - 存储形式：String/List/Set（根据返回类型）
   - 过期策略：变更频率相关（热门房间列表 1 分钟，历史统计 30 分钟）
   - 失效机制：基于标签的缓存失效

```javascript
// 缓存操作示例（伪代码）
async function getRoomWithCache(roomId) {
  const cacheKey = `room:${roomId}`;

  // 尝试从缓存获取
  const cachedRoom = await redisClient.hgetall(cacheKey);
  if (cachedRoom && Object.keys(cachedRoom).length > 0) {
    return deserializeRoom(cachedRoom);
  }

  // 缓存未命中，从数据库获取
  const room = await db.rooms.findOne({ roomId });
  if (!room) return null;

  // 写入缓存
  const serialized = serializeRoom(room);
  const pipeline = redisClient.pipeline();

  // 使用哈希存储房间数据
  Object.entries(serialized).forEach(([field, value]) => {
    pipeline.hset(cacheKey, field, value);
  });

  // 设置过期时间
  const ttl = room.status === "waiting" ? 1800 : 600; // 活跃30分钟，闲置10分钟
  pipeline.expire(cacheKey, ttl);

  // 添加到索引集合
  pipeline.sadd("active:rooms", roomId);

  await pipeline.exec();
  return room;
}
```

#### 8.2.3 缓存一致性保障

确保缓存与数据库同步的策略：

1. **过期策略组合**：

   - 基于时间的被动过期（TTL）
   - 基于事件的主动失效
   - 基于查询频率的自适应过期

2. **更新模式**：

   - 房间和用户数据：Cache-Aside 模式
   - 实时游戏状态：Write-Back 模式
   - 查询缓存：缓存失效模式

3. **版本控制**：

   - 缓存项包含数据版本
   - 更新时验证版本一致性
   - 版本冲突时回源到数据库

4. **缓存穿透防护**：
   - 空值缓存（短 TTL）
   - 布隆过滤器预检
   - 请求合并处理

```javascript
// 缓存一致性示例（伪代码）
async function updateGameStateWithConsistency(gameId, updateFunc) {
  const cacheKey = `game:${gameId}`;
  const lockKey = `lock:${cacheKey}`;

  // 获取分布式锁
  const lock = await redisClient.acquireLock(lockKey, 10000); // 10秒锁

  try {
    // 读取当前缓存和版本
    const cached = await redisClient.get(cacheKey);
    let currentState, currentVersion;

    if (cached) {
      const parsed = JSON.parse(cached);
      currentState = parsed.state;
      currentVersion = parsed.version;
    } else {
      // 缓存未命中，从数据库读取
      const dbState = await db.gameStates.findOne({ gameId });
      currentState = dbState ? dbState.state : null;
      currentVersion = dbState ? dbState.version : 0;
    }

    if (!currentState) {
      throw new Error(`Game ${gameId} not found`);
    }

    // 应用更新
    const { newState, events } = await updateFunc(currentState);
    const newVersion = currentVersion + 1;

    // 更新缓存（立即可见）
    await redisClient.set(
      cacheKey,
      JSON.stringify({
        state: newState,
        version: newVersion,
        updatedAt: Date.now(),
      })
    );

    // 异步持久化到数据库
    persistStateAsync(gameId, newState, newVersion, events);

    // 发布更新事件
    await redisClient.publish(
      "game:updates",
      JSON.stringify({
        gameId,
        version: newVersion,
        eventIds: events.map((e) => e.eventId),
      })
    );

    return { newState, version: newVersion };
  } finally {
    // 释放锁
    await lock.release();
  }
}

// 异步持久化
async function persistStateAsync(gameId, state, version, events) {
  try {
    // 首先存储事件
    if (events && events.length > 0) {
      await db.events.insertMany(events);
    }

    // 存储状态，使用版本号确保一致性
    const result = await db.gameStates.updateOne(
      { gameId, version: version - 1 },
      {
        $set: {
          state,
          version,
          updatedAt: new Date(),
        },
      }
    );

    if (result.modifiedCount === 0) {
      // 版本冲突，需要解决
      console.warn(
        `版本冲突：游戏 ${gameId} 版本 ${version - 1} -> ${version}`
      );
      // 重新读取最新状态，可能需要合并或覆盖策略
    }
  } catch (error) {
    console.error("持久化游戏状态失败", error);
    // 添加到重试队列
    await addToRetryQueue("gameStatePersistence", {
      gameId,
      state,
      version,
      events,
    });
  }
}
```

### 8.3 并发操作处理

游戏系统需要处理多种并发场景，确保数据一致性和操作原子性：

#### 8.3.1 分布式锁

使用 Redis 实现高效分布式锁：

1. **锁类型**：

   - 游戏操作锁：`lock:game:{gameId}`
   - 房间操作锁：`lock:room:{roomId}`
   - 用户操作锁：`lock:user:{userId}`
   - 全局操作锁：`lock:global:{operationType}`

2. **锁实现**：

   - 基于 Redlock 算法实现
   - 支持锁过期自动释放（避免死锁）
   - 支持锁刷新（长操作续期）
   - 支持锁层级和优先级

3. **锁使用策略**：
   - 细粒度锁定（最小操作范围）
   - 避免锁升级（防止死锁）
   - 超时自动释放（防止资源泄露）
   - 操作重试机制

```javascript
// 分布式锁实现（伪代码）
class DistributedLock {
  constructor(redisClient) {
    this.redis = redisClient;
    this.lockPrefix = "lock:";
    this.defaultTimeout = 30000; // 30秒
    this.retryDelay = 200; // 200毫秒
    this.retryCount = 5; // 最多重试5次
  }

  async acquire(resource, timeout = this.defaultTimeout) {
    const lockKey = `${this.lockPrefix}${resource}`;
    const lockValue = uuidv4(); // 生成唯一锁标识
    const deadline = Date.now() + timeout;

    let retries = 0;
    while (Date.now() < deadline) {
      // 尝试获取锁
      const acquired = await this.redis.set(
        lockKey,
        lockValue,
        "NX", // 仅当键不存在时设置
        "PX", // 毫秒为单位的过期时间
        timeout
      );

      if (acquired) {
        // 返回锁对象
        return {
          resource,
          value: lockValue,
          timeout,
          release: async () => {
            // 使用Lua脚本确保原子性释放锁
            const script = `
              if redis.call("get", KEYS[1]) == ARGV[1] then
                return redis.call("del", KEYS[1])
              else
                return 0
              end
            `;
            await this.redis.eval(script, 1, lockKey, lockValue);
          },
          extend: async (additionalTime) => {
            // 延长锁过期时间
            const script = `
              if redis.call("get", KEYS[1]) == ARGV[1] then
                return redis.call("pexpire", KEYS[1], ARGV[2])
              else
                return 0
              end
            `;
            await this.redis.eval(
              script,
              1,
              lockKey,
              lockValue,
              additionalTime
            );
          },
        };
      }

      // 锁获取失败，等待后重试
      if (++retries >= this.retryCount) {
        break;
      }

      await new Promise((resolve) => setTimeout(resolve, this.retryDelay));
    }

    throw new Error(`Failed to acquire lock for resource: ${resource}`);
  }
}
```

#### 8.3.2 并发控制模式

根据不同操作类型采用合适的并发控制模式：

1. **乐观并发控制**：

   - 适用于：读多写少的场景（如房间设置更新）
   - 实现：版本号检查（CAS 操作）
   - 冲突处理：客户端重试或合并更新

2. **悲观并发控制**：

   - 适用于：高竞争资源（如游戏状态更新）
   - 实现：操作前获取分布式锁
   - 锁粒度：尽量细化（gameId, userId 等）

3. **MVCC（多版本并发控制）**：

   - 适用于：查询与更新混合场景
   - 实现：数据版本链，读取指定版本
   - 优点：读操作不阻塞写操作

4. **队列化处理**：
   - 适用于：顺序敏感的操作（如游戏事件处理）
   - 实现：Redis 列表或专用消息队列
   - 策略：单线程处理队列保证顺序

```javascript
// 乐观并发控制示例（伪代码）
async function updateRoomSettings(roomId, settings, expectedVersion) {
  const result = await db.rooms.updateOne(
    { roomId, version: expectedVersion },
    {
      $set: { settings, updatedAt: new Date() },
      $inc: { version: 1 },
    }
  );

  if (result.modifiedCount === 0) {
    // 版本不匹配，获取当前版本
    const currentRoom = await db.rooms.findOne(
      { roomId },
      { projection: { version: 1, settings: 1 } }
    );

    if (!currentRoom) {
      throw new Error("Room not found");
    }

    // 版本冲突处理
    const mergedSettings = mergeSettings(currentRoom.settings, settings);
    return updateRoomSettings(roomId, mergedSettings, currentRoom.version);
  }

  // 成功更新，刷新缓存
  await invalidateCache(`room:${roomId}`);
  return { success: true, newVersion: expectedVersion + 1 };
}

// 队列化处理示例（伪代码）
const gameEventQueues = {}; // 每个游戏一个队列

async function processGameEvent(gameId, event) {
  // 确保该游戏有一个事件队列
  if (!gameEventQueues[gameId]) {
    gameEventQueues[gameId] = {
      queue: [],
      processing: false,
    };
  }

  const queueItem = {
    event,
    resolve: null,
    reject: null,
  };

  // 创建Promise，在事件处理后解析
  const promise = new Promise((resolve, reject) => {
    queueItem.resolve = resolve;
    queueItem.reject = reject;
  });

  // 将事件添加到队列
  gameEventQueues[gameId].queue.push(queueItem);

  // 如果队列没有在处理中，启动处理
  if (!gameEventQueues[gameId].processing) {
    processGameEventQueue(gameId);
  }

  return promise;
}

async function processGameEventQueue(gameId) {
  const gameQueue = gameEventQueues[gameId];
  gameQueue.processing = true;

  while (gameQueue.queue.length > 0) {
    const item = gameQueue.queue[0];

    try {
      // 处理单个事件
      const result = await applyGameEventWithTransaction(gameId, item.event);
      item.resolve(result);
    } catch (error) {
      item.reject(error);
    }

    // 移除已处理的事件
    gameQueue.queue.shift();
  }

  gameQueue.processing = false;

  // 如果长时间没有事件，清理队列对象
  setTimeout(() => {
    if (gameEventQueues[gameId] && gameEventQueues[gameId].queue.length === 0) {
      delete gameEventQueues[gameId];
    }
  }, 300000); // 5分钟后
}
```

#### 8.3.3 限流与降级

系统实现多层限流保护机制：

1. **API 限流**：

   - 按用户限流：每用户每分钟最大请求数
   - 按 IP 限流：防止单 IP 大量请求
   - 按操作类型限流：关键操作（如创建房间）单独限流

2. **资源限流**：

   - 单用户最大同时游戏数：2
   - 单用户最大创建房间数：5
   - 单房间最大事件频率：10 次/秒

3. **自适应限流**：

   - 基于系统负载动态调整限流阈值
   - 高负载时提高限流严格程度
   - 支持按优先级调整限流策略

4. **服务降级**：
   - 定义核心与非核心功能
   - 高负载时自动关闭非核心功能
   - 应用渐进式降级策略

```javascript
// 限流实现（伪代码）
class RateLimiter {
  constructor(redisClient) {
    this.redis = redisClient;
    this.limitPrefix = "ratelimit:";
  }

  async checkLimit(key, limit, windowSeconds = 60) {
    const now = Math.floor(Date.now() / 1000);
    const windowKey = `${this.limitPrefix}${key}:${Math.floor(
      now / windowSeconds
    )}`;

    // 增加计数器
    const count = await this.redis.incr(windowKey);

    // 首次设置过期时间
    if (count === 1) {
      await this.redis.expire(windowKey, windowSeconds);
    }

    // 检查是否超出限制
    const allowed = count <= limit;

    return {
      allowed,
      current: count,
      limit,
      remaining: Math.max(0, limit - count),
      resetAt: Math.floor(now / windowSeconds) * windowSeconds + windowSeconds,
    };
  }

  async checkUserAPILimit(userId, apiPath, limit = 100) {
    return await this.checkLimit(`user:${userId}:api:${apiPath}`, limit);
  }

  async checkIPLimit(ip, limit = 1000) {
    return await this.checkLimit(`ip:${ip}`, limit);
  }

  async checkGameActionLimit(gameId, action, limit = 10, windowSeconds = 1) {
    return await this.checkLimit(
      `game:${gameId}:action:${action}`,
      limit,
      windowSeconds
    );
  }
}

// 服务降级示例
const degradationLevels = {
  0: {
    // 正常模式
    enableHistory: true,
    enableStats: true,
    enableChat: true,
    enableReplay: true,
    maxRoomsPerUser: 5,
  },
  1: {
    // 轻度降级
    enableHistory: true,
    enableStats: true,
    enableChat: true,
    enableReplay: false, // 禁用回放功能
    maxRoomsPerUser: 3,
  },
  2: {
    // 中度降级
    enableHistory: true,
    enableStats: false, // 禁用统计
    enableChat: true,
    enableReplay: false,
    maxRoomsPerUser: 2,
  },
  3: {
    // 重度降级
    enableHistory: false, // 禁用历史
    enableStats: false,
    enableChat: false, // 禁用聊天
    enableReplay: false,
    maxRoomsPerUser: 1,
  },
};

// 根据系统负载动态设置降级级别
async function adjustDegradationLevel() {
  // 获取系统负载指标
  const metrics = await getSystemMetrics();

  let level = 0;
  if (metrics.cpuUsage > 80 || metrics.memoryUsage > 85) {
    level = 3; // 重度降级
  } else if (metrics.cpuUsage > 70 || metrics.memoryUsage > 75) {
    level = 2; // 中度降级
  } else if (metrics.cpuUsage > 60 || metrics.memoryUsage > 65) {
    level = 1; // 轻度降级
  }

  // 设置当前降级级别
  await redisClient.set("system:degradation:level", level);
  return degradationLevels[level];
}
```

通过以上并发控制和性能优化策略，阿瓦隆游戏系统能够应对高并发访问场景，提供稳定、高效的游戏体验，同时确保数据一致性和安全性。

## 9. 监控与运维

阿瓦隆游戏系统需要全面的监控与运维体系，确保系统稳定运行并及时发现和解决问题。

### 9.1 监控系统架构

系统采用多层次的监控架构，覆盖从基础设施到业务指标的各个方面：

```plantuml
@startuml
!theme plain
skinparam backgroundColor transparent
skinparam componentStyle uml2

package "监控目标" {
  [基础设施监控] as InfraMon
  [服务监控] as ServiceMon
  [API监控] as ApiMon
  [业务监控] as BizMon
  [用户体验监控] as UxMon
}

package "监控工具" {
  [Prometheus] as Prom
  [Grafana] as Graf
  [ElasticSearch] as ES
  [Kibana] as Kibana
  [Jaeger] as Jaeger
  [AlertManager] as Alert
}

InfraMon --> Prom
ServiceMon --> Prom
ApiMon --> Prom
ApiMon --> ES
BizMon --> ES
BizMon --> Prom
UxMon --> ES

Prom --> Graf : 可视化
ES --> Kibana : 可视化
Prom --> Alert : 告警
ES --> Alert : 告警
Jaeger --> Graf : 链路追踪

@enduml
```

#### 9.1.1 监控指标体系

系统定义了全面的监控指标体系：

1. **基础设施指标**

   - CPU/内存/磁盘/网络使用率
   - 节点存活状态
   - 数据库读写延迟
   - 缓存命中率和内存使用
   - 网络流量和连接数

2. **服务健康指标**

   - 服务可用性（SLA）
   - 服务错误率和重试率
   - 实例数量和分布
   - 启动/关闭时间
   - 资源消耗

3. **API 指标**

   - 请求量和成功率
   - 响应时间分布（P50/P90/P99）
   - 错误率和类型分布
   - API 调用路径分布
   - 接口热点分析

4. **业务指标**

   - 活跃房间数和游戏数
   - 玩家在线数和分布
   - 房间创建/加入/退出速率
   - 游戏完成率和持续时间
   - 断线重连率和恢复率

5. **用户体验指标**
   - 前端加载时间
   - 界面响应延迟
   - 错误触发率
   - 用户操作路径
   - 会话持续时间

```javascript
// Prometheus指标定义示例（伪代码）
const metrics = {
  // API指标
  apiRequestCounter: new prometheus.Counter({
    name: "api_requests_total",
    help: "Total number of API requests",
    labelNames: ["method", "path", "status"],
  }),

  apiResponseTime: new prometheus.Histogram({
    name: "api_response_time_seconds",
    help: "API response time in seconds",
    labelNames: ["method", "path"],
    buckets: [0.01, 0.05, 0.1, 0.5, 1, 2, 5, 10],
  }),

  // 游戏业务指标
  activeGamesGauge: new prometheus.Gauge({
    name: "active_games_count",
    help: "Number of currently active games",
  }),

  roomCreationCounter: new prometheus.Counter({
    name: "room_creation_total",
    help: "Total number of room creations",
  }),

  gameCompletionCounter: new prometheus.Counter({
    name: "game_completion_total",
    help: "Total number of completed games",
    labelNames: ["winning_team", "player_count"],
  }),

  // 缓存指标
  cacheHitCounter: new prometheus.Counter({
    name: "cache_hit_total",
    help: "Total number of cache hits",
    labelNames: ["cache_type"],
  }),

  cacheMissCounter: new prometheus.Counter({
    name: "cache_miss_total",
    help: "Total number of cache misses",
    labelNames: ["cache_type"],
  }),
};
```

### 9.2 日志管理

系统实现统一的日志管理机制，确保可追溯性和问题排查能力：

#### 9.2.1 日志分级与格式

1. **日志级别**：

   - ERROR：系统错误，需要立即关注
   - WARN：潜在问题，需要监控
   - INFO：一般操作信息
   - DEBUG：调试信息，仅开发环境开启
   - TRACE：详细追踪，特殊场景临时开启

2. **日志格式**：标准化的 JSON 格式日志
   ```javascript
   {
     "timestamp": "2023-06-15T09:15:23.456Z",
     "level": "INFO",
     "service": "room-service",
     "instance": "room-service-pod-3",
     "traceId": "trace-12345",
     "userId": "U9876543210",
     "message": "Room created successfully",
     "data": {
       "roomId": "R1234567890",
       "playerCount": 1,
       "settings": { /* 房间设置摘要 */ }
     }
   }
   ```

#### 9.2.2 日志收集与存储

使用 ELK (Elasticsearch, Logstash, Kibana) 堆栈进行日志管理：

1. **日志收集**：

   - 服务内使用日志库直接输出结构化日志
   - Filebeat 采集容器和节点日志
   - Logstash 进行解析、过滤和转换

2. **日志存储**：

   - 短期日志（7 天）存储在热节点
   - 中期日志（90 天）存储在暖节点
   - 长期日志（1 年以上）压缩存储在冷节点
   - 关键操作日志永久保存

3. **索引策略**：
   - 按服务类型和时间范围分片
   - 自动索引生命周期管理
   - 对高频查询字段建立专用索引

```yaml
# Filebeat配置示例
filebeat.inputs:
  - type: container
    paths:
      - /var/log/containers/*.log
    json.keys_under_root: true
    json.add_error_key: true
    processors:
      - add_kubernetes_metadata:
          host: ${NODE_NAME}
          matchers:
            - logs_path:
                logs_path: "/var/log/containers/"

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
  index: "avalon-logs-%{+yyyy.MM.dd}"
  pipeline: "avalon-log-pipeline"
```

#### 9.2.3 关键日志场景

系统重点关注以下关键日志场景：

1. **用户操作日志**：

   - 房间创建、加入、退出
   - 游戏开始、结束
   - 关键游戏操作（组队、投票等）

2. **数据变更日志**：

   - 游戏状态重要变更
   - 配置修改
   - 数据修复和回滚操作

3. **异常日志**：

   - API 调用异常
   - 业务规则违反
   - 状态不一致
   - 性能异常

4. **安全日志**：
   - 认证和授权事件
   - 敏感操作
   - 异常访问模式

```javascript
// 关键操作日志示例（伪代码）
function logGameAction(gameId, userId, action, details) {
  logger.info("Game action performed", {
    gameId,
    userId,
    action,
    details,
    timestamp: new Date().toISOString(),
    traceId: getCurrentTraceId(),
    source: "game-state-service",
    category: "game-action",
  });

  // 关键操作额外记录到专用集合
  if (CRITICAL_ACTIONS.includes(action)) {
    db.actionAudit.insertOne({
      gameId,
      userId,
      action,
      details,
      timestamp: new Date(),
      metadata: {
        clientIp: getClientIp(),
        userAgent: getUserAgent(),
        sessionId: getSessionId(),
      },
    });
  }
}
```

### 9.3 告警系统

系统建立多级告警机制，及时响应各类异常情况：

#### 9.3.1 告警分级

根据严重程度和影响范围，将告警分为四个级别：

1. **致命（P0）**：

   - 定义：全局服务不可用，严重数据问题
   - 响应：立即响应（SLA < 5 分钟）
   - 通知：电话+短信+邮件+工作群，24 小时值班人员

2. **严重（P1）**：

   - 定义：部分功能不可用，性能严重下降
   - 响应：快速响应（SLA < 15 分钟）
   - 通知：短信+邮件+工作群，工作时间内全员

3. **警告（P2）**：

   - 定义：非核心功能异常，性能下降
   - 响应：常规响应（SLA < 1 小时）
   - 通知：邮件+工作群，相关负责人

4. **提醒（P3）**：
   - 定义：潜在问题，需要关注的异常
   - 响应：计划响应（SLA < 1 天）
   - 通知：邮件，相关开发人员

#### 9.3.2 告警规则

系统定义了一系列基于指标和日志的告警规则：

1. **系统资源告警**：

   - CPU 使用率 > 80% 持续 5 分钟（P2）
   - 内存使用率 > 85% 持续 5 分钟（P2）
   - 磁盘使用率 > 90%（P2）

2. **服务可用性告警**：

   - API 错误率 > 5% 持续 3 分钟（P1）
   - API 响应时间 P99 > 2 秒 持续 5 分钟（P2）
   - 服务实例数低于最小阈值（P1）

3. **数据库告警**：

   - MongoDB 副本集节点离线（P1）
   - 数据库查询延迟 > 500ms（P2）
   - 连接池使用率 > 90%（P2）

4. **业务指标告警**：
   - 断线重连失败率 > 10%（P1）
   - 游戏创建失败率 > 5%（P1）
   - 活跃用户数突发下降 > 30%（P2）

```yaml
# Prometheus告警规则示例
groups:
  - name: avalon-alerts
    rules:
      - alert: HighApiErrorRate
        expr: sum(rate(api_requests_total{status=~"5.."}[5m])) / sum(rate(api_requests_total[5m])) > 0.05
        for: 3m
        labels:
          severity: P1
        annotations:
          summary: "High API error rate"
          description: 'API error rate is above 5% for 3 minutes ({{ $value | printf "%.2f" }}%)'

      - alert: GameCreationFailures
        expr: sum(rate(game_creation_failed_total[5m])) / sum(rate(game_creation_total[5m])) > 0.05
        for: 5m
        labels:
          severity: P1
        annotations:
          summary: "High game creation failure rate"
          description: 'Game creation is failing at a rate of {{ $value | printf "%.2f" }}%'
```

#### 9.3.3 告警处理流程

告警触发后的标准处理流程：

1. **告警触发**：

   - 监控系统检测到指标超过阈值
   - 生成告警事件并分配唯一 ID
   - 根据严重级别确定通知方式和对象

2. **告警响应**：

   - 接收人确认收到告警
   - 初步评估影响范围和原因
   - 记录处理进展
   - 必要时启动应急预案

3. **告警解决**：

   - 实施修复措施
   - 验证问题解决
   - 确认服务和指标恢复正常
   - 关闭告警事件

4. **事后分析**：
   - 编写故障报告
   - 进行根因分析
   - 总结经验教训
   - 更新监控和告警规则

```plantuml
@startuml
!theme plain
skinparam backgroundColor transparent
skinparam activityBackgroundColor white
skinparam activityBorderColor black
skinparam activityDiamondBackgroundColor white
skinparam activityDiamondBorderColor black

start
:监控指标超过阈值|
:生成告警事件|
:通知相关人员|

if (是否是工作时间?) then (是)
  :值班工程师处理|
else (否)
  :24小时值班人员响应|
endif

:确认告警|
:评估影响范围|

if (是否为误报?) then (是)
  :调整告警规则|
  :记录误报原因|
  stop
else (否)
  if (是否需要紧急处理?) then (是)
    :启动应急预案|
    :通知更多响应人员|
  else (否)
    :按标准流程处理|
  endif
endif

:实施修复措施|
:验证问题解决|
:关闭告警|
:编写故障报告|
:更新文档和监控规则|
stop
@enduml
```

### 9.4 运维自动化

系统采用 DevOps 实践，自动化部署、配置和运维流程：

#### 9.4.1 CI/CD 流水线

使用 GitLab CI/CD 实现自动化部署流水线：

1. **开发环境**：

   - 代码提交自动触发构建
   - 单元测试和集成测试
   - 自动部署到开发环境

2. **测试环境**：

   - 合并到开发分支触发
   - 完整测试套件
   - 性能和负载测试
   - 安全扫描

3. **预发布环境**：

   - 合并到预发布分支触发
   - 冒烟测试和回归测试
   - 金丝雀发布

4. **生产环境**：
   - 手动批准后部署
   - 分批次滚动更新
   - 自动健康检查
   - 自动回滚机制

```yaml
# GitLab CI配置示例
stages:
  - build
  - test
  - deploy_dev
  - deploy_staging
  - deploy_prod

build_job:
  stage: build
  script:
    - npm install
    - npm run build
  artifacts:
    paths:
      - dist/

test_job:
  stage: test
  script:
    - npm run lint
    - npm run test:unit
    - npm run test:integration

deploy_dev_job:
  stage: deploy_dev
  script:
    - deploy-script.sh dev
  environment:
    name: development
  only:
    - develop

deploy_staging_job:
  stage: deploy_staging
  script:
    - deploy-script.sh staging
  environment:
    name: staging
  only:
    - staging

deploy_prod_job:
  stage: deploy_prod
  script:
    - deploy-script.sh production
  environment:
    name: production
  when: manual
  only:
    - master
```

#### 9.4.2 配置管理

使用 Kubernetes ConfigMaps 和 Secrets 进行配置管理：

1. **环境配置**：

   - 不同环境的配置存储在 ConfigMaps 中
   - 使用标签区分环境和服务
   - 配置变更自动触发服务更新

2. **敏感配置**：

   - 数据库凭证和 API 密钥存储在 Secrets 中
   - 使用 HashiCorp Vault 管理密钥
   - 自动轮换密钥

3. **配置版本控制**：
   - 所有配置变更记录历史
   - 支持配置回滚
   - 配置审计日志

#### 9.4.3 容量规划与扩展

自动化的容量规划和扩展机制：

1. **自动扩展策略**：

   - 基于 CPU 使用率的水平扩展
   - 基于内存使用率的垂直扩展
   - 基于队列长度的扩展

2. **容量预测**：

   - 基于历史数据的增长预测
   - 季节性波动分析
   - 活动影响评估

3. **资源分配**：
   - 不同服务的资源配额
   - 服务优先级定义
   - 资源回收策略

```yaml
# Kubernetes HPA配置示例
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: game-state-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: game-state-service
  minReplicas: 3
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 75
    - type: Pods
      pods:
        metric:
          name: game_processing_queue_length
        target:
          type: AverageValue
          averageValue: 10
```

通过全面的监控与运维体系，阿瓦隆游戏系统能够实现高可用、高性能和可扩展的服务，确保玩家获得稳定流畅的游戏体验。

## 10. 开发与测试计划

为确保游戏数据管理模块的高质量交付，本节详细规划开发和测试阶段的工作内容、时间安排和资源分配。

### 10.1 开发计划

游戏数据管理模块的开发将按照以下阶段进行：

#### 10.1.1 阶段划分

```plantuml
@startuml
!theme plain
skinparam backgroundColor transparent
skinparam ganttBackgroundColor white
skinparam ganttBarBackgroundColor LightBlue
skinparam ganttBarBorderColor DarkBlue

project starts 2023-08-01

[T1-数据模型设计] starts 2023-08-01 and lasts 7 days
[T1-数据模型设计] is colored in Crimson/LightPink

[T2-数据访问层开发] starts at [T1-数据模型设计]'s end and lasts 10 days
[T2-数据访问层开发] is colored in MediumBlue/LightBlue

[T3-游戏状态同步] starts at [T2-数据访问层开发]'s end and lasts 12 days
[T3-游戏状态同步] is colored in ForestGreen/LightGreen

[T4-事件溯源实现] starts at [T2-数据访问层开发]'s end and lasts 10 days
[T4-事件溯源实现] is colored in DarkOrange/LightYellow

[T5-高并发优化] starts at [T3-游戏状态同步]'s end and lasts 8 days
[T5-高并发优化] is colored in DarkViolet/Lavender

[T6-API实现] starts at [T4-事件溯源实现]'s end and lasts 10 days
[T6-API实现] is colored in DarkSlateGray/LightCyan

[T7-集成与优化] starts at [T5-高并发优化]'s end and lasts 7 days and starts at [T6-API实现]'s end
[T7-集成与优化] is colored in DarkRed/MistyRose
@enduml
```

1. **准备阶段（1 周）**

   - 技术方案评审和细化
   - 环境搭建和工具配置
   - 依赖服务对接

2. **基础开发阶段（3 周）**

   - 数据模型实现
   - 数据访问层开发
   - 基本 CRUD 操作实现
   - 单元测试覆盖

3. **核心功能开发阶段（4 周）**

   - 实时状态同步机制实现
   - 事件溯源系统开发
   - 断线重连数据恢复
   - 高并发性能优化

4. **API 与集成阶段（2 周）**

   - RESTful API 实现
   - WebSocket 推送服务
   - 与其他模块集成
   - 文档生成

5. **优化与完善阶段（2 周）**
   - 性能优化
   - 安全性增强
   - 边界情况处理
   - 监控与日志完善

#### 10.1.2 任务分解与资源分配

核心开发任务分解及资源分配如下：

| 任务 ID | 任务描述             | 工作量(人日) | 开发人员 | 依赖任务         |
| ------- | -------------------- | ------------ | -------- | ---------------- |
| T1.1    | 房间数据模型设计     | 3            | 架构师 A | -                |
| T1.2    | 游戏进程数据模型设计 | 3            | 架构师 A | -                |
| T1.3    | 历史记录数据模型设计 | 2            | 架构师 A | -                |
| T2.1    | MongoDB 数据访问层   | 5            | 后端 A   | T1.1, T1.2, T1.3 |
| T2.2    | Redis 缓存访问层     | 4            | 后端 B   | T1.1, T1.2       |
| T2.3    | 数据访问单元测试     | 3            | 测试 A   | T2.1, T2.2       |
| T3.1    | WebSocket 连接管理   | 4            | 后端 C   | -                |
| T3.2    | 状态变更推送         | 5            | 后端 C   | T3.1             |
| T3.3    | 断线重连状态恢复     | 4            | 后端 B   | T3.2, T2.2       |
| T4.1    | 事件模型定义         | 2            | 架构师 A | T1.2             |
| T4.2    | 事件存储与查询       | 4            | 后端 A   | T4.1             |
| T4.3    | 状态重建引擎         | 5            | 后端 D   | T4.2             |
| T5.1    | 读写分离实现         | 3            | 后端 A   | T2.1             |
| T5.2    | 缓存策略优化         | 3            | 后端 B   | T2.2             |
| T5.3    | 并发冲突解决         | 4            | 后端 D   | T4.3             |
| T6.1    | 房间管理 API         | 3            | 后端 C   | T2.1, T2.2       |
| T6.2    | 游戏状态 API         | 4            | 后端 D   | T3.2, T4.3       |
| T6.3    | 历史记录 API         | 3            | 后端 A   | T2.1             |
| T7.1    | 与用户系统集成       | 3            | 后端 C   | T6.1, T6.2       |
| T7.2    | 与游戏逻辑集成       | 4            | 后端 D   | T6.2             |
| T7.3    | 与分析系统集成       | 3            | 后端 A   | T6.3             |

#### 10.1.3 技术债务控制

为确保代码质量和可维护性，我们将采取以下技术债务控制措施：

1. **代码质量门禁**：

   - 静态代码分析工具集成（ESLint, SonarQube）
   - 单元测试覆盖率要求（>80%）
   - 代码评审流程（至少 1 名审核者）

2. **文档要求**：

   - 核心接口必须有 API 文档
   - 复杂算法必须有设计文档
   - 数据模型必须有清晰的说明

3. **定期技术债务清理**：
   - 每个迭代预留 20%时间处理技术债务
   - 每月进行一次代码重构日
   - 定期更新依赖和安全补丁

### 10.2 测试计划

游戏数据管理模块的测试将采用多层次、多阶段的综合测试策略：

#### 10.2.1 测试类型与阶段

```plantuml
@startuml
!theme plain
skinparam backgroundColor transparent
skinparam activityBackgroundColor white
skinparam activityBorderColor black
skinparam activityDiamondBackgroundColor white
skinparam activityDiamondBorderColor black

title 测试流程图

|开发阶段|
start
:代码编写;
:单元测试\n(开发者执行);
|测试阶段|
:代码评审;
:集成测试\n(持续集成环境);
:功能测试\n(测试环境);
fork
  :性能测试\n(专用环境);
fork again
  :安全测试\n(专用环境);
fork again
  :兼容性测试\n(多端环境);
end fork
:系统测试\n(预发布环境);
:验收测试\n(预发布环境);
|发布阶段|
:灰度发布\n(部分生产用户);
:全量发布\n(全部生产用户);
stop
@enduml
```

1. **单元测试**：

   - 覆盖所有数据访问方法
   - 模拟外部依赖（数据库、缓存、消息队列）
   - 验证边界条件和异常处理

2. **集成测试**：

   - 验证与 MongoDB、Redis 等实际服务的交互
   - 测试组件间通信
   - 验证配置和环境一致性

3. **功能测试**：

   - 基于用户场景的端到端测试
   - 房间创建、加入、游戏进行的完整流程
   - 游戏数据保存和加载的正确性

4. **性能测试**：

   - 单接口性能基准测试
   - 高并发场景模拟（1000 同时在线玩家）
   - 长时间运行稳定性测试（24 小时）
   - 资源使用监控

5. **安全测试**：

   - 数据访问权限验证
   - 输入验证和注入防护
   - 敏感数据保护

6. **兼容性测试**：
   - 不同微信版本兼容性
   - iOS/Android 平台兼容性
   - 不同网络条件测试（弱网、不稳定网络）

#### 10.2.2 测试用例设计

关键测试场景和用例：

| 测试场景     | 测试条件               | 预期结果                         | 优先级 |
| ------------ | ---------------------- | -------------------------------- | ------ |
| 游戏房间创建 | 正常网络条件           | 房间创建成功，返回房间 ID        | 高     |
| 游戏房间创建 | 弱网络条件             | 房间最终创建成功，客户端收到确认 | 高     |
| 玩家加入房间 | 房间存在且未满         | 加入成功，房间信息更新           | 高     |
| 玩家加入房间 | 房间已满               | 返回适当错误，不允许加入         | 中     |
| 游戏状态更新 | 正常游戏进行           | 所有玩家收到实时状态更新         | 高     |
| 玩家断线重连 | 短时间断线（<5 分钟）  | 重连后状态恢复正常               | 高     |
| 玩家断线重连 | 长时间断线（>30 分钟） | 游戏状态仍可恢复                 | 中     |
| 并发状态更新 | 多玩家同时操作         | 状态更新有序，无冲突             | 高     |
| 游戏完成     | 游戏正常结束           | 历史记录正确保存                 | 中     |
| 历史记录查询 | 查询近期游戏           | 正确返回历史记录列表             | 中     |
| 游戏回放     | 请求已完成游戏回放     | 正确返回完整游戏事件流           | 低     |
| 高并发测试   | 1000 用户同时在线      | 系统稳定，响应时间<200ms         | 高     |
| 灾难恢复     | 服务器故障             | 通过事件日志恢复状态             | 高     |

#### 10.2.3 测试环境与数据

1. **测试环境**：

   - 开发环境：开发人员本地和共享开发服务器
   - 测试环境：独立的测试服务器集群
   - 预发布环境：与生产环境配置相同
   - 性能测试环境：专用高规格硬件

2. **测试数据**：

   - 合成测试数据：自动生成的模拟游戏数据
   - 生产数据副本：脱敏后的真实游戏数据
   - 边界案例数据：特殊设计的边界条件数据

3. **测试工具**：
   - 单元测试：Jest、Mocha
   - API 测试：Postman、JMeter
   - 性能测试：Gatling、K6
   - 监控：Prometheus + Grafana

#### 10.2.4 验收标准

游戏数据管理模块的验收标准：

1. **功能完整性**：

   - 所有需求文档中列出的功能都已实现
   - 所有用例测试通过率 100%
   - 关键路径测试全部通过

2. **性能指标**：

   - API 平均响应时间 < 50ms（P95）
   - 高峰期（1000 并发）响应时间 < 200ms（P95）
   - CPU 使用率峰值 < 70%
   - 内存使用率峰值 < 80%

3. **可靠性指标**：

   - 24 小时稳定性测试无故障
   - 故障恢复时间 < 5 分钟
   - 数据一致性检查通过

4. **代码质量**：
   - 单元测试覆盖率 > 80%
   - 静态代码分析无严重/高风险问题
   - 所有安全扫描通过

### 10.3 风险与缓解策略

开发过程中可能面临的主要风险和相应的缓解策略：

| 风险                 | 影响 | 可能性 | 缓解策略                                                       |
| -------------------- | ---- | ------ | -------------------------------------------------------------- |
| MongoDB 性能瓶颈     | 高   | 中     | 提前进行架构验证，准备读写分离和分片方案，优化索引策略         |
| WebSocket 连接稳定性 | 高   | 中     | 实现健壮的重连机制，消息队列缓冲，客户端状态恢复逻辑           |
| 高并发冲突问题       | 高   | 高     | 使用乐观锁和版本控制，实现冲突检测和解决策略，提前进行压力测试 |
| 数据一致性挑战       | 高   | 中     | 采用事件溯源模式，实现幂等操作，定期一致性校验                 |
| 技术栈复杂度         | 中   | 中     | 加强团队培训，提供详细文档，建立技术支持机制                   |
| 开发进度延迟         | 中   | 中     | 合理规划缓冲时间，关键路径优先开发，周度进度跟踪               |
| 需求变更             | 中   | 高     | 采用敏捷开发流程，增量交付，保持架构灵活性                     |

### 10.4 里程碑计划

项目关键里程碑计划：

| 里程碑           | 计划日期   | 交付内容                         | 验收方式           |
| ---------------- | ---------- | -------------------------------- | ------------------ |
| M1: 设计完成     | 2023-08-07 | 详细设计文档，数据模型，API 规范 | 设计评审会议       |
| M2: 基础功能完成 | 2023-08-25 | 数据访问层，基本 CRUD 功能       | 功能演示，单元测试 |
| M3: 核心功能完成 | 2023-09-22 | 状态同步，事件溯源，高并发支持   | 功能测试，集成测试 |
| M4: API 完成     | 2023-10-06 | 全部 API 实现，文档生成          | API 测试，文档评审 |
| M5: 集成完成     | 2023-10-20 | 与其他模块集成，系统测试通过     | 系统测试，性能测试 |
| M6: 验收通过     | 2023-10-27 | 所有测试通过，准备发布           | 验收测试，演示会议 |

通过以上详细的开发与测试计划，游戏数据管理模块将以高质量、可靠的方式按期交付，确保阿瓦隆微信小游戏的数据管理需求得到全面满足。

## 11. 总结与展望

通过本技术方案，我们为阿瓦隆微信小游戏设计了一套全面的游戏数据管理解决方案。该方案采用多层架构设计，结合 MongoDB 持久化存储和 Redis 内存缓存，实现了高效、可靠的游戏数据管理系统。

核心技术亮点包括：

1. 基于事件溯源的游戏状态管理，确保数据完整性和可追溯性
2. 实时状态同步机制，提供流畅的多人游戏体验
3. 多级缓存策略，优化读写性能
4. 高并发控制机制，保障数据一致性
5. 完善的监控与运维体系

未来的优化方向：

1. 引入机器学习技术，分析游戏数据，优化游戏体验
2. 探索区块链技术在游戏数据完整性验证方面的应用
3. 进一步优化冷热数据分离策略，提升系统性能
4. 扩展游戏数据 API，支持更丰富的数据分析场景
5. 建立更完善的数据安全与隐私保护机制

通过本方案的实施，阿瓦隆微信小游戏将拥有稳定、高效的游戏数据管理能力，为玩家提供流畅、可靠的游戏体验，同时为游戏运营提供有力的数据支持。
